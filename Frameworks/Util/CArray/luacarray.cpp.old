/*
  Lua module to provide efficient access to C arrays
*/

#include <string.h>

#ifdef __cplusplus
extern "C"
{
#endif
  #include "lua.h"
  #include "lualib.h"
  #include "lauxlib.h"
#ifdef __cplusplus
}
#endif

typedef struct {
  const void *ptr;
  char type;
  int size;
  int own; // 1 if array was created by Lua and needs to be deleted
} structCArray;

static structCArray * lua_checkcarray(lua_State *L, int narg) {
  void *ud = luaL_checkudata(L, narg, "carray_mt");
  luaL_argcheck(L, *(structCArray **)ud != NULL, narg, "invalid carray");
  return (structCArray *)ud;
}

static int lua_carray_newString(lua_State *L) {
  if (!lua_isstring(L, 1)) luaL_error(L, "Need string argument");

  size_t len;
  const char *str = lua_tolstring(L, 1, &len);

  structCArray *ud = (structCArray *)lua_newuserdata(L, sizeof(structCArray));
  ud->size = len;
  ud->type = 'c';
  ud->own = 1;

  char *p_char = new char[len];
  memcpy(p_char, str, len);
  ud->ptr = p_char;

  luaL_getmetatable(L, "carray_mt");
  lua_setmetatable(L, -2);
  return 1;
}

static int lua_carray_newFloat(lua_State *L) {
  int size = 0;
  bool istable = lua_istable(L, 1);
  if (istable)
    size = lua_objlen(L, 1);
  else
    size = luaL_optinteger(L, 1, 1);

  structCArray *ud = (structCArray *)lua_newuserdata(L, sizeof(structCArray));
  ud->size = size;
  ud->type = 'f';
  ud->own = 1;

  // Allocate float array:
  float *p_float = new float[size];
  ud->ptr = p_float;

  // Copy table values to array:
  if (istable) {
    for (int i = 0; i < size; i++) {
      lua_pushinteger(L, i+1);
      lua_gettable(L, 1);
      p_float[i] = lua_tonumber(L, -1);
      lua_pop(L, 1); // integer key
    }
  }

  luaL_getmetatable(L, "carray_mt");
  lua_setmetatable(L, -2);
  return 1;
}

static int lua_carray_new(lua_State *L) {
  const char *type = luaL_optstring(L, 1, "double");

  int size;
  bool istable = lua_istable(L, 2);
  if (istable) {
    size = lua_objlen(L, 2);
  }
  else {
    size = luaL_optinteger(L, 2, 1);
  }
  structCArray *ud = (structCArray *)lua_newuserdata(L, sizeof(structCArray));

  ud->size = size;
  ud->type = type[0];
  ud->own = 1;

  int i;
  unsigned char *p_uchar;
  char *p_char;
  short *p_short;
  int *p_int;
  unsigned int *p_uint;
  float *p_float;
  double *p_double;

  switch (ud->type) {
  case 'b':
    p_uchar = new unsigned char[size];
    ud->ptr = p_uchar;
    if (istable) {
      for (i = 0; i < size; i++) {
	lua_pushinteger(L, i+1);
	// Lua stack: table, userdata, index (top)
	lua_gettable(L, -3);
	p_uchar[i] = lua_tointeger(L, -1);
	lua_pop(L, 1);
      }
    }
    break;
  case 'c':
    p_char = new char[size];
    ud->ptr = p_char;
    if (istable) {
      for (i = 0; i < size; i++) {
	lua_pushinteger(L, i+1);
	lua_gettable(L, -3);
	p_char[i] = lua_tointeger(L, -2);
	lua_pop(L, 1);
      }
    }
    break;
  case 's':
    p_short = new short[size];
    ud->ptr = p_short;
    if (istable) {
      for (i = 0; i < size; i++) {
	lua_pushinteger(L, i+1);
	lua_gettable(L, -3);
	p_short[i] = lua_tointeger(L, -2);
	lua_pop(L, 1);
      }
    }
    break;
  case 'i':
    p_int = new int[size];
    ud->ptr = p_int;
    if (istable) {
      for (i = 0; i < size; i++) {
	lua_pushinteger(L, i+1);
	lua_gettable(L, -3);
	p_int[i] = lua_tointeger(L, -2);
	lua_pop(L, 1);
      }
    }
    break;
  case 'u':
    p_uint = new unsigned int[size];
    ud->ptr = p_uint;
    if (istable) {
      for (i = 0; i < size; i++) {
	lua_pushinteger(L, i+1);
	lua_gettable(L, -3);
	p_uint[i] = lua_tointeger(L, -2);
	lua_pop(L, 1);
      }
    }
    break;
  case 'f':
    p_float = new float[size];
    ud->ptr = p_float;
    if (istable) {
      for (i = 0; i < size; i++) {
	lua_pushinteger(L, i+1);
	lua_gettable(L, -3);
	p_float[i] = lua_tonumber(L, -1);
	lua_pop(L, 1);
      }
    }
    break;
  case 'd':
    p_double = new double[size];
    ud->ptr = p_double;
    if (istable) {
      for (i = 0; i < size; i++) {
	lua_pushinteger(L, i+1);
	lua_gettable(L, -3);
	p_double[i] = lua_tonumber(L, -1);
	lua_pop(L, 1);
      }
    }
    break;
  default:
    ud->ptr = new char[size];
  }

  luaL_getmetatable(L, "carray_mt");
  lua_setmetatable(L, -2);
  return 1;
}

static int lua_carray_cast(lua_State *L) {
  /*
  // Check for lightuserdata carray
  if (!lua_islightuserdata(L, 1)) {
    lua_pushnil(L);
    return 1;
  }
  */
  const char *type = luaL_optstring(L, 2, "double");
  int size = luaL_optinteger(L, 3, 1);
  structCArray *ud = (structCArray *)lua_newuserdata(L, sizeof(structCArray));
  ud->ptr = lua_topointer(L, 1);
  ud->size = size;
  ud->type = type[0];
  ud->own = 0;

  luaL_getmetatable(L, "carray_mt");
  lua_setmetatable(L, -2);
  return 1;
}

static int lua_carray_delete(lua_State *L) {
  structCArray *p = lua_checkcarray(L, 1);
  if (p->own) {
    delete p->ptr;
  }
  return 0;
}

static int lua_carray_set(lua_State *L) {
  structCArray *p = lua_checkcarray(L, 1);
  int index = luaL_checkint(L, 2) - 1; // Convert lua 1-index to C 0-index
  if ((index < 0) || (index >= p->size)) {
    return luaL_error(L, "index out of bounds");
  }

  double val = lua_tonumber(L, 3);
  switch (p->type) {
  case 'b':
    ((unsigned char *)p->ptr)[index] = val;
    break;
  case 'c':
    ((char *)p->ptr)[index] = val;
    break;
  case 's':
    ((short *)p->ptr)[index] = val;
    break;
  case 'i':
    ((int *)p->ptr)[index] = val;
    break;
  case 'u':
    ((unsigned int *)p->ptr)[index] = val;
    break;
  case 'f':
    ((float *)p->ptr)[index] = val;
    break;
  case 'd':
    ((double *)p->ptr)[index] = val;
    break;
  default:
    ((char *)p->ptr)[index] = val;
  }

  return 0;
}

static int lua_carray_get(lua_State *L) {
  structCArray *p = lua_checkcarray(L, 1);
  int index = luaL_checkint(L, 2) - 1; // Convert lua 1-index to C 0-index

  if ((index < 0) || (index >= p->size)) {
    lua_pushnil(L);
    return 1;
  }

  double val;
  switch (p->type) {
  case 'b':
    val = ((unsigned char *)p->ptr)[index];
    break;
  case 'c':
    val = ((char *)p->ptr)[index];
    break;
  case 's':
    val = ((short *)p->ptr)[index];
    break;
  case 'i':
    val = ((int *)p->ptr)[index];
    break;
  case 'u':
    val = ((unsigned int *)p->ptr)[index];
    break;
  case 'f':
    val = ((float *)p->ptr)[index];
    break;
  case 'd':
    val = ((double *)p->ptr)[index];
    break;
  default:
    lua_pushnil(L);
    return 1;
  }
  lua_pushnumber(L, val);
  return 1;
}

static int lua_carray_pointer(lua_State *L) {
  structCArray *p = lua_checkcarray(L, 1);

  lua_pushlightuserdata(L, (void *) p->ptr);
  lua_pushlstring(L, &(p->type), 1);
  lua_pushinteger(L, p->size);
  return 3;
}

static int lua_carray_tostring(lua_State *L) {
  structCArray *p = lua_checkcarray(L, 1);
  lua_pushfstring(L, "carray(%p): '%c' type, %d len, %d own",
		  p->ptr, p->type, p->size, p->own);
  return 1;
}

static int lua_carray_len(lua_State *L) {
  structCArray *p = lua_checkcarray(L, 1);
  lua_pushinteger(L, p->size);
  return 1;
}

static const struct luaL_reg carray_functions[] = {
  {"string", lua_carray_newString},
  {"float", lua_carray_newFloat},
  {"new", lua_carray_new},
  {"cast", lua_carray_cast},
  {"set", lua_carray_set},
  {"get", lua_carray_get},
  {"pointer", lua_carray_pointer},

  {NULL, NULL}
};

static const struct luaL_reg carray_methods[] = {
  {"__gc", lua_carray_delete},
  {"__newindex", lua_carray_set},
  {"__tostring", lua_carray_tostring},
  {"__len", lua_carray_len},

  {NULL, NULL}
};

#ifdef __cplusplus
extern "C"
#endif
int luaopen_carray (lua_State *L) {
  luaL_newmetatable(L, "carray_mt");

  // Array access: mt.__index = get(); mt.__newindex = set()
  // Not compatible with OO access
  lua_pushstring(L, "__index");
  lua_pushcfunction(L, lua_carray_get);
  lua_settable(L, -3);

  luaL_register(L, NULL, carray_methods);
  luaL_register(L, "carray", carray_functions);

  // NULL pointer field
  lua_pushstring(L, "NULL");
  lua_pushlightuserdata(L, 0);
  lua_settable(L, -3);

  return 1;
}
