module(..., package.seeall);

require('Body')
require('World')
require('walk')
require('vector')
require('vcm')
require('Config')

t0 = 0;

timeout = Config.BodyFSM.approach.timeout;
maxStep = Config.BodyFSM.approach.maxStep;
tLost = Config.BodyFSM.approach.tLost;

xKick = Config.BodyFSM.approach.xKick;
xTarget=Config.BodyFSM.approach.xTarget;
yTarget=Config.BodyFSM.approach.yTarget;
yKickMin = Config.BodyFSM.approach.yKickMin;
yKickMax = Config.BodyFSM.approach.yKickMax;

rFar = Config.BodyFSM.approach.rFar;
pickup=Config.BodyFSM.approach.pickup; --Should we do pickup or not?
HeadFSM=require(Config.HeadFSM.name);

ball_tracking=false;

dist_front= 0;
dist_left=0;
dist_right=0;
obstacle=0;

function entry()
  print(_NAME.." entry");
  t0 = Body.get_time();
  print("Kick dir:",vcm.kickdir)

  ball=vcm.get_ball();
  pose=vcm.get_pose();

  if ball.t<0.2 then 
	ball_tracking=true;
	HeadFSM.sm:set_state('headKick');	--Fix camera during approaching
  end

  update_kick_target();
  occ_checked=false;
  vcm.backpedal=0;
end



function update()
  local t = Body.get_time();

  -- get ball position
  ball=vcm.get_ball();
  pose=vcm.get_pose();

  if ball.t<0.2 and ball_tracking==false then 
	ball_tracking=true;
	HeadFSM.sm:set_state('headKick');	--Fix camera during approaching
  end

--print(ball.x,xKick,ball.y,yKickMin,yKickMax)

  ballR = math.sqrt(ball.x^2 + ball.y^2);

  if Config.BodyFSM.level.freespace>2 and 
     ballR<0.22 and occ_checked==false then
     occ_checked=true;
     occ=check_occupancy();
     if occ==3 then
--We are always doing walkkick front when something is in the way 
	vcm.kickdir=3;        
--[[
          obstacle=1;
	  goal_attack=vcm.world.goalAttack;
	  if goal_attack[1]*pose.x > 0 then --left side, do kick to right
 	      vcm.kickdir=4;        
	      vcm.backpedal=2; --sidestep left
	  else
 	      vcm.kickdir=5;  
	      vcm.backpedal=3; --sidestep right
	  end
--]]
     elseif occ==1 then
	vcm.kickdir=3;        
     elseif occ==2 then
	vcm.kickdir=3;        
     end
     update_kick_target();
  end

  -- calculate walk velocity based on ball position
  vStep = vector.new({0,0,0});
  vStep[1] = .4*(ball.x - xTarget);

  if pickup==1 or vcm.kickdir>0 then  --pickup or sidekick
      vStep[2] = .75*(ball.y - yTarget);
  else
      vStep[2] = .75*(ball.y - sign(ball.y)*yTarget);
  end

  scale = math.min(maxStep/math.sqrt(vStep[1]^2+vStep[2]^2), 1);
  vStep = scale*vStep;

  ballA = math.atan2(ball.y - math.max(math.min(ball.y, 0.05), -0.05), ball.x+0.10);
  if pickup==1 then
	vStep[3]=0;
  else
        vStep[3] = 0.5*ballA;
  end

  --SJ: turn torwards the goal, not the ball
  attackBearing = vcm.get_attack_bearing();

  if vcm.approachtype==1 then --kick to left
     attackBearing=vcm.mod_angle(attackBearing - 70*math.pi / 180);
  elseif vcm.approachtype==2 then --kick to right
     attackBearing=vcm.mod_angle(attackBearing + 70*math.pi / 180);
  elseif vcm.approachtype==3 then
     attackBearing=vcm.mod_angle(attackBearing + math.pi / 6);
  end



  if vcm.kickDir==0 then
	if attackBearing>10*math.pi/180 then
	    vStep[3]=0.2;
	elseif attackBearing<-10*math.pi/180 then
	    vStep[3]=-0.2;
	else
 	    vStep[3]=0;
	end
  else
	  vStep[3]=0;
  end    

  --SJ: when the ball is on the side, backstep a bit
  local wAngle=math.atan2(vStep[2],vStep[1]);
  if math.abs(wAngle)>70*math.pi/180 then
	vStep[1]=vStep[1]-0.03;
  end

  walk.set_velocity(vStep[1],vStep[2],vStep[3]);

  if (t - ball.t > tLost) then
    HeadFSM.sm:set_state('headScan');	
    print("bodyApproach-ballLost")
    return "ballLost";
  end
  if (t - t0 > timeout) then
    HeadFSM.sm:set_state('headTrack');	
    print("bodyApproach-timeout")
    return "timeout";
  end
  if (ballR > rFar) then
    HeadFSM.sm:set_state('headTrack');	
    print("bodyApproach-ballFar",ballR)
    return "ballFar";
  end


  if pickup==1 then
     if ((ball.x < xKick) and (ball.y < yKickMax) and
        (ball.y > yKickMin)) then 
	--and (ball.t< 0.2) then
	print("PICKUP")
       return "pickup";  
     end
  end

 tBallKick=0.4;

  --Front stationary kick
   if vcm.kickdir==0 then 
       if ((ball.x < xKick) and (math.abs(ball.y) < yKickMax) and
       	(math.abs(ball.y) > yKickMin)) 
	and (t-ball.t < tBallKick) then
	   print("Ball pos: ",ball.x,ball.y);
           print("bodyApproach-kick")
 	   return "kick";  
	end

  --Stationary side kicks
  elseif vcm.kickdir==1 or vcm.kickdir==2 then
       if ((ball.x < xKick) and (ball.y < yKickMax) and
       	(ball.y > yKickMin)) and t-ball.t<tBallKick then
	    print("Ball pos: ",ball.x,ball.y);
           print("bodyApproach-kick")
  	    return "kick";  
	end
  
  --Front walking kick
  elseif vcm.kickdir==3 then
       if ((ball.x < xKick) and (math.abs(ball.y) < yKickMax) and
       	(math.abs(ball.y) > yKickMin)) and (t-ball.t < tBallKick) then
	   print("Ball pos: ",ball.x,ball.y);
           print("bodyApproach-walkkick")
	   return "walkkick";  
	end

  --Side walking kicks
  elseif vcm.kickdir==4 or vcm.kickdir==5 then
       if ((ball.x < xKick) and (ball.y < yKickMax) and
       	(ball.y > yKickMin)) and (t-ball.t < tBallKick) then
 	   print("Ball pos: ",ball.x,ball.y);
           print("bodyApproach-sweepkick")
	   return "walkkick";  
	end
  end


end

function exit()
--   HeadFSM.sm:set_state('headTrack');	
end

function sign(x)
  if (x > 0) then return 1;
  elseif (x < 0) then return -1;
  else return 0;
  end
end

function update_occupancy()










end




function check_occupancy()
  if Team.role==3 then
     return 0; --don't check obstacke for goalie
  end
--[[
  print(vcm.etc.occumap[36],
	vcm.etc.occumap[37],
	vcm.etc.occumap[2],
	vcm.etc.occumap[3]);
--]]

  front_occ=math.min(
	vcm.etc.occumap[37],
	vcm.etc.occumap[2]);


  left_occ=0.5*(vcm.etc.occumap[35]+vcm.etc.occumap[36]);
  right_occ=0.5*(vcm.etc.occumap[3]+vcm.etc.occumap[4]);


  if front_occ<0.4 then
        Speak2.talk('Blocked')
	return 3;
  elseif left_occ<0.4 then
        Speak2.talk('Left obstacle')
	return 1;
  elseif right_occ<0.4 then
        Speak2.talk('Right obstacle')
	return 1;
  else
--      Speak2.talk('Freespace')
	return 0;
  end

end


function update_kick_target()

  if Config.BodyFSM.level.kick==0 then
	vcm.kickdir=0;
  elseif Config.BodyFSM.level.kick==3 and
	Config.BodyFSM.level.freespace==0
	then
	vcm.kickdir=3;
  end

  --straight kick
  if vcm.kickdir==0 then 
	xKick = Config.BodyFSM.approach.xKick;
	xTarget=Config.BodyFSM.approach.xTarget;

	yTarget=Config.BodyFSM.approach.yTarget;
	yKickMin = Config.BodyFSM.approach.yKickMin;
	yKickMax = Config.BodyFSM.approach.yKickMax;  

  --left foot sidekick (to right)
  elseif vcm.kickdir==1 then 
	xKick = Config.BodyFSM.approach.xKick;
	xTarget=Config.BodyFSM.approach.xTarget;

	yTarget=   -0.025;
	yKickMin = -0.04;
	yKickMax =  0.01;

	yTarget=   -0.025;
	yKickMin = -0.05;
	yKickMax =  0.0;

  --right foot sidekick (to left)
  elseif vcm.kickdir==2 then 
	xKick = Config.BodyFSM.approach.xKick;
	xTarget=Config.BodyFSM.approach.xTarget;

	yTarget=   0.015;
	yKickMin = -0.01;
	yKickMax = 0.04;

	yTarget=   0.025;
	yKickMin = -0.0;
	yKickMax = 0.05;

  elseif  vcm.kickdir==4 then 
	xKick = Config.BodyFSM.approach.xKick+0.01;
	xTarget=Config.BodyFSM.approach.xTarget+0.01;

	yTarget=   -0.015;
	yKickMin = -0.04;
	yKickMax =  0.01;

	yTarget=   -0.025;
	yKickMin = -0.05;
	yKickMax =  0.00;

  --right foot sidekick (to left)
  elseif  vcm.kickdir==5 then 
	xKick = Config.BodyFSM.approach.xKick+0.01;
	xTarget=Config.BodyFSM.approach.xTarget+0.01;

	yTarget=   0.015;
	yKickMin = -0.01;
	yKickMax = 0.04;

	yTarget=   0.025;
	yKickMin = 0.0;
	yKickMax = 0.05;




  --walking kick front
  else 
--	xKick = Config.BodyFSM.approach.xKick;
--	xTarget=Config.BodyFSM.approach.xTarget;
	xKick = 0.18;
	xTarget=0.16;

	xTarget=0.14; --To approach faster

	yTarget=Config.BodyFSM.approach.yTarget;
	yKickMin = Config.BodyFSM.approach.yKickMin;
	yKickMax = Config.BodyFSM.approach.yKickMax;  
  end
end
