module(..., package.seeall);

require('Body')
require('World')
require('walk')
require('vector')
require('vcm')
require('Config')
require('Team')
require('OccupancyMap')

t0 = 0;
timeout = Config.BodyFSM.chase.timeout;
maxStep = Config.BodyFSM.chase.maxStep;
rClose = Config.BodyFSM.chase.rClose;
tLost = Config.BodyFSM.chase.tLost;
rTurn= Config.BodyFSM.chase.rTurn;

defender_position=0;

function entry()
  print(_NAME.." entry");
  t0 = Body.get_time();
  max_speed=0;
  set_approach_type();

  count=0;
  check_defender_position();
  approach_checked=0;

  ball=vcm.get_ball();
  ballR = math.sqrt(ball.x^2 + ball.y^2);
  if ballR< 1.0 then
    approach_checked=1;
  end
end



function update()
  count=count+1;

  local t = Body.get_time();

  ball=vcm.get_ball();
  pose=vcm.get_pose();
  ballR = math.sqrt(ball.x^2 + ball.y^2);


  if ballR< 1.0 and approach_checked==0 then
     set_approach_type();
  end

--[[
  if count%400==0 and ballR>0.60 then 
     set_approach_type();
  end
--]]

  if count%400==0 then 
     check_defender_position();
  end

  ballxy=vector.new( {ball.x,ball.y,0} );
  posexya=vector.new( {pose.x, pose.y, pose.a} );

  ballGlobal=vcm.pose_global(ballxy,posexya);
  goalGlobal=vcm.world.goalAttack;

  aBallLocal=math.atan2(ball.y,ball.x); 

  aBall=math.atan2(ballGlobal[2]-pose.y, ballGlobal[1]-pose.x);
  aGoal=math.atan2(goalGlobal[2]-ballGlobal[2],goalGlobal[1]-ballGlobal[1]);


  --In what angle should we approach the ball?



--[[
  if vcm.approachtype==1 then
     aGoal=aGoal - 70*math.pi / 180;
  elseif vcm.approachtype==2 then
     aGoal=aGoal + 70*math.pi / 180;
  elseif vcm.approachtype==3 then
     aGoal=aGoal + math.pi / 6;
  end

--]]


  angle1=vcm.mod_angle(aGoal-aBall);


  if Config.BodyFSM.level.chase==11 then 
  	homePose=getDefenderHomePose();

  elseif Config.BodyFSM.level.chase==12 then --Advanced chase test
        homePose=getAttackerHomePose2();	

  elseif Team.role==1 then --Attacker
     if Config.BodyFSM.level.chase==0 then --Normal chase-orbit
        homePose=getAttackerHomePose();	
     else
        homePose=getAttackerHomePose2();	
     end
  else 
  	homePose=getDefenderHomePose();
  end

  uPose=vector.new({pose.x,pose.y,pose.a})
  pRelative=vcm.pose_relative(homePose,uPose);
  rRelative=math.sqrt(pRelative[1]^2+pRelative[2]^2);
  aRelative=math.atan2(pRelative[2],pRelative[1]);

  --Basic chase code
  vStep = vector.new({0,0,0});
  aTurn=math.exp(-0.5*(rRelative/rTurn)^2);

--  if Config.BodyFSM.level.chase==1 and Team.role==1 then --Advanced vel.generation

  if Team.role==2 or
   Config.BodyFSM.level.chase==11 then
    --Velocity generation for defender, always face the ball

    aTurn = 0; --always facing the ball
    vStep[1] = maxStep*pRelative[1]/rRelative;
    vStep[2] = maxStep*pRelative[2]/rRelative;
    if (t-ball.t<4.0) then vStep[3]= aBallLocal;
    else vStep[3]=0.5*(aTurn*pRelative[3] + (1-aTurn)*aRelative);
    end

    scale = math.min(maxStep/math.sqrt(vStep[1]^2+vStep[2]^2), 1);
    vStep[1],vStep[2] = scale*vStep[1],scale*vStep[2];
    walk.set_velocity(vStep[1],vStep[2],vStep[3]);

  else	--Velocity generation #2
   
    if rRelative>0.6 and 
	Config.BodyFSM.level.speed>0 and
	math.abs(pRelative[3])<45*math.pi/180 
	then
       if Config.BodyFSM.level.speed==2 then
 	  maxStep=0.09; --36cm/s
       else maxStep = 0.08; --32cm/s
       end
       if max_speed==0 and 
	math.abs(pRelative[3])<30*math.pi/180 
	then
	  max_speed=1;
 	  Speak2.play('./mp3/max_speed.mp3',50)
       end
    elseif 
        rRelative>0.4 and 
	Config.BodyFSM.level.speed==2 and
	math.abs(pRelative[3])<45*math.pi/180 
	then
        maxStep=0.09; --36cm/s
        if max_speed==0 and 
  	  math.abs(pRelative[3])<30*math.pi/180 then

 	  maxStep=0.09; --36cm/s
	  max_speed=1;
 	  Speak2.play('./mp3/max_speed.mp3',50)
       end
    else
	maxStep = Config.BodyFSM.chase.maxStep;
    end
--[[
    if Config.BodyFSM.level.speed==0 then
       maxStep = 0.06; --20cm/s
    end
--]]
    vStep[1] = maxStep*pRelative[1]/rRelative;
    if rRelative>0.8 then
       vStep[2]=0;
    elseif rRelative>0.6 then
       vStep[2] = 0.3*maxStep*pRelative[2]/rRelative;
    else
       if math.abs(aRelative)>45*180/math.pi then
  	vStep[2] = maxStep*pRelative[2]/rRelative;
  	aTurn=0;
       else
  	vStep[2] = 0.3*maxStep*pRelative[2]/rRelative;
       end	
    end

    scale = math.min(maxStep/math.sqrt(vStep[1]^2+vStep[2]^2), 1);
    vStep = scale*vStep;
    vStep[3]=0.5*(aTurn*pRelative[3] + (1-aTurn)*aRelative);
    vStep[1]=math.max(0,vStep[1]) --Shouldn't allow the robot to go backside
    walk.set_velocity(vStep[1],vStep[2],vStep[3]);

  end

  if (t - ball.t > tLost) then
    return "ballLost";
  end
  if (t - t0 > timeout) then
    return "timeout";
  end

  rCloseX=0.08;
  rCloseY=0.15;
  rCloseA=20*math.pi/180;

  tBall=0.5;


  if Team.role==2 or
   Config.BodyFSM.level.chase==11 then
   --Defender shouldn't attack

  else
     if Config.BodyFSM.level.chase==1 then	
     if Team.role==1 then 
      if math.abs(pRelative[1])<rCloseX and
	math.abs(pRelative[2])<rCloseY and
	math.abs(pRelative[3])<rCloseA and
	t-ball.t<tBall then
        return "ballClose";
      end
     else
      if (ballR < rClose) and
	t-ball.t<tBall then
        return "ballClose";
      end
     end
    elseif Config.BodyFSM.level.chase==12 then
      if math.abs(pRelative[1])<rCloseX and
	math.abs(pRelative[2])<rCloseY and
	math.abs(pRelative[3])<rCloseA then
        return "stop";
     end
    else
     if (ballR < rClose) and
	t-ball.t<tBall then
        return "ballClose";
     end
   end
 
  end

end

function getAttackerHomePose()
  return ballGlobal;
end


function getAttackerHomePose2()
--TODO: home to kickable pose, not ball pose

--  print(pose.x,pose.y,pose.a*180/math.pi,angle1*180/math.pi)

  rDist1=0.40;
  rDist2=0.20;
  rOrbit=0.40;
  rTurn2=0.08;

  if math.abs(angle1)<math.pi/2 then
    rDist=math.min(rDist1,math.max(rDist2,ballR-rTurn2));
    local homepose={
	ballGlobal[1]-math.cos(aGoal)*rDist,
	ballGlobal[2]-math.sin(aGoal)*rDist,
	aGoal};
    return homepose;
  elseif angle1>0 then
    local homepose={
	ballGlobal[1]+math.cos(-aBall+math.pi/2)*rOrbit,
	ballGlobal[2]-math.sin(-aBall+math.pi/2)*rOrbit,
	aBall};
    return homepose;

  else
    local homepose={
	ballGlobal[1]+math.cos(-aBall-math.pi/2)*rOrbit,
	ballGlobal[2]-math.sin(-aBall-math.pi/2)*rOrbit,
	aBall};
    return homepose;
  end
end

function getDefenderHomePose()
  local t = Body.get_time();
  balla=math.atan2(ball.y,ball.x);
  ballxy=vector.new( {ball.x,ball.y,0} );
  posexya=vector.new( {pose.x, pose.y, pose.a} );
  ballGlobal=vcm.pose_global(ballxy,posexya);

  goal_defend=vcm.world.goalDefend;
  local defendVec={ballGlobal[1]-goal_defend[1],ballGlobal[2]-goal_defend[2],0};
  local ballDistGoal=math.sqrt(defendVec[1]^2+defendVec[2]^2); 
  local homePose={}


  local dist=math.min(math.max(ballDistGoal - 0.50, 0.50),2.50);
  homePose[1]=goal_defend[1] + defendVec[1]/ballDistGoal*dist;
  homePose[2]=goal_defend[2] + defendVec[2]/ballDistGoal*dist;
  homePose[2]=homePose[2]-0.5*sign(homePose[2])
  defendAngleGlobal = math.atan2(defendVec[2],defendVec[1]);
  homePose[3]=defendAngleGlobal;



--[[


  if Config.BodyFSM.level.defender==1 then
    if defender_position==0 then 
     --General defender code
     homePose[1]=ballGlobal[1]-0.5*sign(ballGlobal[1]);
     homePose[2]=ballGlobal[2]-1.0*sign(ballGlobal[2]);
     homePose[3]=ballGlobal[3];

    elseif defender_position==1 then 
     --Zone defender 

    end
  else
      homePose=0.6*ballGlobal;
      goal_defend=vcm.world.goalDefend;
      if goal_defend[1]>0 then
          homePose[1],homePose[2]=
  	  homePose[1]+ 0.80,
  	  homePose[2]+ 0.50;
      else
          homePose[1],homePose[2]=
  	  homePose[1]- 0.80,
  	  homePose[2]- 0.50;
      end
      if (t - ball.t <4.0 ) then 
  	--Ball observed recently, turn toward ball
	  homePose[3] = ballGlobal[3];
      else
  	--Stand against the goal
        goal_defend=vcm.world.goalDefend;
  	defendAngleGlobal = math.atan2(
	  	pose.y - goal_defend[2],
      		pose.x - goal_defend[1]
	    );
  	homePose[3]=defendAngleGlobal;
      end
  end
--]]

  return homePose;
end

function check_defender_position()

  if Team.buddy_id==0 then  
     defender_position=0;
     return;
  end

  ball=vcm.get_ball();
  pose=vcm.get_pose();
  ballR = math.sqrt(ball.x^2 + ball.y^2);
  goalAttack=vcm.world.goalAttack;
  ballxy=vector.new( {ball.x,ball.y,0} );
  posexya=vector.new( {pose.x, pose.y, pose.a} );

  buddyPose=Team.buddy_pose;
  local vMine={goalAttack[1]-pose.x,goalAttack[2]-pose.y};
  local vBuddy={goalAttack[1]-buddyPose.x,
		goalAttack[2]-buddyPose.y};
  local rMine=math.sqrt(vMine[1]^2+vMine[2]^2);
  local rBuddy=math.sqrt(vBuddy[1]^2+vBuddy[2]^2);
 
  if rMine > rBuddy + 1.0 then 
    --Defender is far behind attacker, go back to blocking position
     defender_position=1;
     return;
  end       

  if rMine<rBuddy - 0.5 then
    --Attacker is behind defender, go to supporting position
     defender_position=0;
     return;
  end
end

function exit()
end

function sign(s)
  if s>0 then return 1;
  else return -1;
  end
end



function set_approach_type()

  local t = Body.get_time();
--print("Approaching check")
-- Kickoff first kick check
  if vcm.firstkick>0 and t-vcm.firstkick < 10.0 then
     vcm.approachtype=3; --30 degree offset
     return;
  end
  vcm.approachtype=0;


  return; --do not use other approaches for actual matches

--[[
  if Config.BodyFSM.level.kick==0 then return;end --Stationary straight kick only
  if Config.BodyFSM.level.kick==3 then return;end --Front walkkick only


  ball=vcm.get_ball();
  pose=vcm.get_pose();
  ballR = math.sqrt(ball.x^2 + ball.y^2);

  ballxy=vector.new( {ball.x,ball.y,0} );
  posexya=vector.new( {pose.x, pose.y, pose.a} );

  ballGlobal=vcm.pose_global(ballxy,posexya);
  goalGlobal=vcm.world.goalAttack;
  goalGlobal2=vcm.world.goalDefend;  
 
  aBall=math.atan2(ballGlobal[2]-pose.y, ballGlobal[1]-pose.x);
  aGoal=math.atan2(goalGlobal[2]-ballGlobal[2],goalGlobal[1]-ballGlobal[1]);
  aTurn=vcm.mod_angle(aGoal-aBall);

  vcm.approachtype=0;  --default: zero 

  thAttack=45*math.pi/180;
  thDefend=45*math.pi/180;

  if goalGlobal[1]<goalGlobal2[1] then
     aGoal1=math.atan2(ballGlobal[2]-goalGlobal[2],ballGlobal[1]-goalGlobal[1]);
     aGoal2=math.atan2(goalGlobal2[2]-ballGlobal[2],goalGlobal2[1]-ballGlobal[1]);
  else
     aGoal1=math.atan2(goalGlobal[2]-ballGlobal[2],goalGlobal[1]-ballGlobal[1]);
     aGoal2=math.atan2(ballGlobal[2]-goalGlobal2[2],ballGlobal[1]-goalGlobal2[1]);
  end

--  print("off def",aGoal*180/math.pi,aGoal2*180/math.pi)

  if Config.BodyFSM.level.corner==1 then
    if aGoal1> thAttack then
	print("Top right")
--        Speak2.talk("Top right")
        vcm.approachtype=1; 
	return;
    elseif aGoal1<-thAttack then
	print("Top left")
        vcm.approachtype=2; 
  --      Speak2.talk("Top left")
	return;
    elseif aGoal2> thDefend then
	--Bottom left corner, do right sidekick
	print("Bottom left")
--        Speak2.talk("Bottom left")
        vcm.approachtype=2; --left sidekick to right
	return;
    elseif aGoal2<-thDefend then
	--Bottom right corner
	print("Bottom right")
  --      Speak2.talk("Bottom right")
        vcm.approachtype=1; --right sidekick to left
	return;
    else
        print("Midfield")
    end	
  end

  if Config.BodyFSM.level.kick==4 then
      rEnemyBallDist=4.0;
      Config.BodyFSM.level.frontfield=1;
   else 
      rEnemyBallDist=Config.BodyFSM.level.frontfielddist;
  end


   if Config.BodyFSM.level.frontfield==1 then
     --allow sidekick near enemy goal
       ballGoal={goalGlobal[2]-ballGlobal[2],goalGlobal[1]-ballGlobal[1]};
       rBallGoalAttack=math.sqrt(ballGoal[1]^2+ballGoal[2]^2);
       thAngle=45*math.pi/180;
       thAngle2=120*math.pi/180;

print("attack goal dist:",rBallGoalAttack,rEnemyBallDist)
print("attack goal angle",aTurn*180/math.pi,thAngle*180/math.pi)

       if rBallGoalAttack<rEnemyBallDist then
print("Dist within range")
          if aTurn> thAngle and aTurn <thAngle2 then
            vcm.approachtype=1; 
	    print("rightkick approach") --kick to left

          elseif  aTurn<(-thAngle) and aTurn> (-thAngle2) then
            vcm.approachtype=2; 
	    print("leftkick approach") --kick to right


          else
print("Front kick")

             vcm.approachtype=0;
	  end
      end
   end
--]]
end
