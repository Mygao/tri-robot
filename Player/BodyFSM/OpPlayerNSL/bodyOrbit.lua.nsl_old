module(..., package.seeall);

require('Body')
require('World')
require('walk')
require('vector')
require('vcm')
require('Config')
require('Team')

t0 = 0;
timeout =Config.BodyFSM.orbit.timeout;
maxStep =Config.BodyFSM.orbit.maxStep;
rOrbit = Config.BodyFSM.orbit.rOrbit;
rFar = Config.BodyFSM.orbit.rFar;
thAlign = Config.BodyFSM.orbit.thAlign;
tLost = Config.BodyFSM.orbit.tLost;

direction = 1;
count=0;

HeadFSM=require(Config.HeadFSM.name);

function entry()
  print(_NAME.." entry");
  t0 = Body.get_time();
--  thAlign=math.max(dapost/2,Config.BodyFSM.orbit.thAlign);

  if (t0-vcm.tHeadGoal>5.0) then
     HeadFSM.sm:set_state('headLookGoal');	--Fix camera during approaching
  end

end


function update()
  local t = Body.get_time();

  ball=vcm.get_ball();
  pose=vcm.get_pose();

  attackBearing,dapost = vcm.get_attack_bearing();

  --In what angle should we kick to?

--[[
  if vcm.approachtype==1 then --kick to left
     attackBearing=vcm.mod_angle(attackBearing - 70*math.pi / 180);
  elseif vcm.approachtype==2 then --kick to right
     attackBearing=vcm.mod_angle(attackBearing + 70*math.pi / 180);
  else
--]]
  if vcm.approachtype==3 then
     attackBearing=vcm.mod_angle(attackBearing + math.pi / 6);
  end


  direction = get_orbit_direction();

  goal_attack=vcm.world.goalAttack;
  ballxy=vector.new( {ball.x,ball.y,0} );
  posexya=vector.new( {pose.x, pose.y, pose.a} );
  ballGlobal=vcm.pose_global(ballxy,posexya);

  ballToGoal={goal_attack[1]-ballGlobal[1],goal_attack[2]-ballGlobal[2]};
  dist_goal=math.sqrt(ballToGoal[1]^2+ballToGoal[2]^2);


  --Basic sidestepping orbiting
  ballR = math.sqrt(ball.x^2 + ball.y^2);
  ballA = math.atan2(ball.y, ball.x+0.07);
  ballA = math.atan2(ball.y, ball.x+0.03);
  dr = ballR - rOrbit;
  aStep = ballA - direction*(90*math.pi/180 - dr/0.40);
  vx = maxStep*math.cos(aStep);
  vy = maxStep*math.sin(aStep);
  va = 0.75*ballA;

  walk.set_velocity(vx, vy, va);

  --This is for kick check
--  attackBearing,dapost = vcm.get_attack_bearing();


  if (t - ball.t > tLost) then
    return "ballLost";
  end
  if (t - t0 > timeout) then
    return "timeout";
  end
  if (ballR > rFar) then
print("ballfar")
    return "ballFar";
  end

  thAlignDribble=20*math.pi/180;
  rDistDribble=3.0;
  rDistDribble=10.0;

  count=count+1;

  --Low level behavior testing without orbit
  if Config.BodyFSM.level.kick==11 then 
        vcm.kickdir=0;  --Stationary kick front
        return "done";
  elseif Config.BodyFSM.level.kick==12 then 
        vcm.kickdir=count%2 + 1;  --Stationary kick left/right
        return "done";
  elseif Config.BodyFSM.level.kick==13 then 
        vcm.kickdir=3;  --Walkkick front
        return "done";
  elseif Config.BodyFSM.level.kick==14 then 
        vcm.kickdir=count%2 + 4;  --Walking kick left/right
        return "done";
  elseif Config.BodyFSM.level.kick==15 then 
        return "dribble";
  end

  --First kick: Don't orbit and do walkkick
  if vcm.firstkick>0 and t-vcm.firstkick < 10.0 then
--After ready, defender will be always right to the attacker
        vcm.kickdir=3;  --Walkkick front
        return "done";
  end

  walkkick_enable=false;


--  print("Goal dist:",dist_goal);

  --When should we do walking kick?
  if 	dist_goal<Config.BodyFSM.rGoalAttackThreshold1 then
	walkkick_enable=true;
  elseif dist_goal<Config.BodyFSM.rGoalAttackThreshold then
	walkkick_enable=false;
  else
	walkkick_enable=true;
  end

--[[
  --Linear check
  if Config.BodyFSM.level.ffwalkkick==2 and 
	math.abs(goal_attack[1]-ballGlobal[1])<
	Config.BodyFSM.rGoalAttackThreshold then
	walkkick_enable=true;
  end

  if Config.BodyFSM.level.bfwalkkick==2 and 
	math.abs(goal_attack[1]-ballGlobal[1])>
	Config.BodyFSM.rGoalDefendThreshold then
	walkkick_enable=true;
  end
--]]

  if Config.BodyFSM.level.kick==16 or 
     Config.BodyFSM.level.kick==0 
     --Only allow stationary front kick
	then 
      if  math.abs(attackBearing)<thAlign then
         vcm.kickdir=0;  --Stationary kick front
         return "done";
      end
  elseif Config.BodyFSM.level.kick==3 then
     --Only allow walking front kick
      if  math.abs(attackBearing)<thAlign then
	if Config.BodyFSM.level.freespace==0 then
            vcm.kickdir=3; 
	elseif Config.BodyFSM.level.freespace==3 then
           vcm.kickdir=3; 
	else
	    print("Freespace check")
            vcm.kickdir=0; 
 	end
        return "done";
      end
  else
     --Select front/side stationary/walking kick

      if walkkick_enable==true then
	if math.abs(attackBearing)<thAlignDribble then
	  if vcm.approachtype==1 then
            vcm.kickdir=5;
    	    return "done"; 
	  elseif vcm.approachtype==2 then
            vcm.kickdir=4;
    	    return "done"; 
	  else
            vcm.kickdir=3;
    	    return "done";  --Sweepkick left
	  end
	end
      else --Stationary kick
        if  math.abs(attackBearing)<thAlign then
	  if vcm.approachtype==1 then
            vcm.kickdir=2;
    	    return "done";  --Sweepkick left
	  elseif vcm.approachtype==2 then
            vcm.kickdir=1;
    	    return "done";  --Sweepkick left
	  else
            vcm.kickdir=0;
    	    return "done";  --Sweepkick left
	  end
	end
      end
  end

end

function exit()
--  print("Kicktype:",vcm.kickdir)
  attackBearing = vcm.get_attack_bearing();
--  print("Kick with attackbearing", attackBearing*180/math.pi)
end

function get_orbit_direction()
  --Default direction
  if (attackBearing > 0) then direction = 1;
  else  direction = -1;   
  end

  return direction;
end

