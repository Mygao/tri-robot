module(..., package.seeall);

require('Body')
require('World')
require('Team')
require('walk')
require('util')
require('vector')

t0 = 0;
maxStep = 0.06;
rClose = 0.20;
thClose = 10.0 * math.pi/180.0;
--timeout = 30.0;
timeout = 60.0; --45
role = Team.role; -- Don't switch roles in update

-- don't start moving right away
--tstart = 2.0;

HeadFSM=require(Config.HeadFSM.name);


function entry()
  print(_NAME.." entry");
  t0 = Body.get_time();
  approached=0;
  role = Team.role;
  if vcm.has_kickoff() then ko='has' else ko='has not' end
  if vcm.is_dropball() then dp='has' else dp='has not' end

  print('My role: '.. role..', Kickoff: '..ko..', Dropball: '..dp);


  -- Declare our home positions
  home = vector.new(World.get_goal_defend());
  if vcm.has_kickoff() then
    print("HAVE KICKOFF!");
    if role==3 then       -- goalie
      home[1] = home[1] - .30 * util.sign(home[1]); -- Don't be right on the line
    elseif role==1 then       -- attacker 
--      home[1] = util.sign(home[1]) * .5;
      home[1] = util.sign(home[1]) * .15;
    elseif role==2 then       -- defender
      home[1] = util.sign(home[1]) * 1.0;
      home[2] = util.sign(home[1]) * 0.5;
    end
--[[
  elseif( vcm.is_dropball() ) then
    print("Have dropball!");
    if role==3 then        -- goalie
      home[1] = home[1] - .30 * util.sign(home[1]); -- Don't be right on the line
    elseif role==1 then       -- attacker 
      home[1] = util.sign(home[1]) * .5;
      home[2] = util.sign(home[1])* 1.0;
    elseif role==2 then       -- defender (Playing up top)
      home[1] = util.sign(home[1]) * .5;
      home[2] = util.sign(home[1])* 1.0;
    end
--]]
  else --Opponent has kickoff
    print('Do not have kickoff');
    if role==3 then -- goalie
      home[1] = home[1] - .30 * util.sign(home[1]); -- Don't be right on the line
    elseif role==1 then       -- attacker 
      home[1] = util.sign(home[1]) * .7;
    else       -- defender
      print('goto defen')
      home[1] = util.sign(home[1]) * 1.3;
      home[2] = util.sign(home[1]) * 0.5;
    end
  end

  print('Going to : ',unpack(home))


end

function update()
  if approached==2 then return; end 

  local t = Body.get_time();
  pose=vcm.get_pose();
  homeRelative = vcm.pose_relative(home, {pose.x, pose.y, pose.a});
  rhome = math.sqrt(homeRelative[1]^2 + homeRelative[2]^2);
  ahome= math.atan2(homeRelative[2], homeRelative[1]);

  centerRelative = vcm.pose_relative(vector.new({0,0,0}), {pose.x, pose.y,pose.a}) 
  acenter= math.atan2(centerRelative[2], centerRelative[1]);

  if rhome<0.20 or approached==1 then
     vx=0;
     vy=0;
     va=.2*acenter;
     approached=1;
  elseif rhome<0.50 then
     maxStep = 0.04;
     vx = maxStep * homeRelative[1]/rhome;
     vy = maxStep * homeRelative[2]/rhome;
     va = .1 * ahome;    
  else
     maxStep = 0.06;
     vx = maxStep * homeRelative[1]/rhome;
     vy= 0;
     va = .2 * ahome;
  end
  
  walk.set_velocity(vx, vy, va);

  -- close and oriented then stop walking
  if approached==1 and math.abs(acenter) < thClose then
    walk.set_velocity(0, 0, 0);
    walk.stopAlign();
    print("APPROACHED")
    approached=2;
    HeadFSM.sm:set_state('headScan');
  end

  if (t - t0 > timeout) then
    print("TIMEOUT")
    walk.stopAlign();
    approached=2;
    HeadFSM.sm:set_state('headScan');
  end

end

function exit()
end


