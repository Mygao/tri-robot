module(..., package.seeall);

require('Config');	-- For Ball and Goal Size
require('ImageProc');
require('HeadTransform');	-- For Projection
require('Body')
require('Vision');

-- Dependency
require('Detection');

-- Define Color
colorOrange = 1;
colorYellow = 2;
colorCyan = 4;
colorField = 8;
colorWhite = 16;

use_point_goal=Config.vision.use_point_goal;
headInverted=Config.vision.headInverted;

-- Rotation box w.r.t centroid
function bboxRot(box,centroid,angle,length)
  local bbox={};
-- Shift to top center point
  local xShift=length/2*math.cos(angle);
  local yShift=-length/2*math.sin(angle);
  -- estimate leftTop and rightBottom Point by swap leftX and rightX
  bbox[2]=math.ceil((box[1]-centroid[1])*math.cos(angle)-
          (box[3]-centroid[2])*math.sin(angle)+centroid[1]+xShift);
  -- topY 
  bbox[3]=math.ceil((box[1]-centroid[1])*math.sin(angle)+
          (box[3]-centroid[2])*math.cos(angle)+centroid[2]+yShift);
  -- rightX
  bbox[1]=math.ceil((box[2]-centroid[1])*math.cos(angle)-
          (box[4]-centroid[2])*math.sin(angle)+centroid[1]+xShift); 
  -- bottomY
  bbox[4]=math.ceil((box[2]-centroid[1])*math.sin(angle)+
          (box[4]-centroid[2])*math.cos(angle)+centroid[2]+yShift);

  return bbox;
end

function detect(color,color2)
  local GDEBUG = 0;
  local goal = {};
  goal.detect = 0;
  if (Vision.colorCount[color] < 100) then
    return goal;
  end

  local postDiameter = 0.10;
  local postHeight = 0.80;
  local goalWidth = 1.40;
  local nPostB = 5;  -- appropriate for scaleB = 4
  local postB = ImageProc.goal_posts(Vision.labelB.data, 
				 Vision.labelB.m, Vision.labelB.n, 
				 color, nPostB);

-- Head Angle check
  local HeadAngle=Body.get_head_position();
--  print(HeadAngle[2]*180/math.pi);
  local HeadAngleThreshold=15*math.pi/180;
  if HeadAngle[2]>=HeadAngleThreshold then 
      if (GDEBUG==1) then print("Facing down, no goalposts") end
      return goal;
  end


  if (not postB) then 
--    if (GDEBUG==1) then print('No goal posts seen');end
    return goal;
  end

  local npost = 0;
  local ivalidB = {};
  local postA = {};

  -- Loop through potential goalpost blobs
--  if (GDEBUG==1) then print('Evaluating...'..color);end
  for i = 1,#postB do
    -- Assume valid until proven false?  I think this is the wrong way...
    local valid = true;

    -- Grab the posts bounding box stats
    local postStats = Detection.bboxStats(color, postB[i].boundingBox);

    -- Double check bounding boxes to get rid of crossbar interference
    -- Do this by forming a lower bounding box, and finding its stats
    local LowerBox=0;  -- Selection of lower or upper variable
    local leftX = postB[i].boundingBox[1];
    local rightX = postB[i].boundingBox[2];
    local topY = postB[i].boundingBox[3];
    local bottomY = postB[i].boundingBox[4];
    local boundingBoxLower={};

    local height1=postStats.axisMajor/4;
    local center1=postStats.centroid[2]/4;

    if headInverted==1 then
--      boundingBoxLower={leftX,rightX,topY,topY*0.4+bottomY*0.6};
       boundingBoxLower={leftX,rightX,topY,center1+height1/2* 0.5};

    else
--      boundingBoxLower={leftX,rightX,topY*0.6+bottomY*0.4,bottomY};
       boundingBoxLower={leftX,rightX,center1-height1/2* 0.5,bottomY};
    end

    local postStats2 = Detection.bboxStats(color, boundingBoxLower);
    -- Check the width of two stats
    local thickness1=postStats.axisMinor;
    local thickness2=postStats2.axisMinor;
    -- If the upper and lower have the same thinness, then the crossbar did not interfere
    if (thickness1/thickness2>1.1) then
      if(GDEBUG==1) then print("Substituting lower bounding box: ", thickness1, thickness2 ); end;
      LowerBox=1;
    	postStats=postStats2;
    end

--
postStats=postStats2;


    -- size and orientation checks
    --SJ: darwin sees tiny goalposts at tilted landmarks, so I increase the min area

    if ((postStats.area < 10) or
      (math.abs(postStats.orientation) < 60*math.pi/180)) then
      if(GDEBUG==1) then
        print("Size and orientation check fail at ",postStats.area,180/math.pi*postStats.orientation);
      end
      valid = false;
    end



    --fill extent check (Are there enough labeled pixels in its bounding box?)
    local extent = postStats.area/(postStats.axisMajor*postStats.axisMinor);
    --local bbox_area = (postStats.boundingBox[2]-postStats.boundingBox[2]+1)
    --                 *(postStats.boundingBox[4]-postStats.boundingBox[3]+1);
    --print("Extent: "..extent..". Area: "..postStats.area..". BBoxArea: "..bbox_area)
    local minExtent = .5; --.35 default
    if (extent < minExtent) then 
      if(GDEBUG==1) then print("Fill extent check fail at",extent); end;
      valid = false; 
    end

    --Bad color check
    local badColorStats=Detection.bboxStats(color2,postB[i].boundingBox);
    local extent2= badColorStats.area / 
                   (postStats.axisMajor * postStats.axisMinor);
    if extent2/extent > 0.1 then
        if(GDEBUG==1) then print("Bad color extent:",extent2/extent); end;
      valid=false;
    end

    -- Aspect ratio check
    local aspect = postStats.axisMajor/postStats.axisMinor;
    local minAspect = 3;
    if postStats.area > 10000 then 
      if(GDEBUG==1) then print("Using looser aspect.  Area: "..postStats.area); end;
      minAspect = 1;
    end
    if ((aspect < minAspect) or (aspect > 15)) then 
      if(GDEBUG==1) then print("Aspect check fail at "..aspect.." Using aspect: "..minAspect..". Area: "..postStats.area); end;
      valid = false; 
    end

    --check edge
    --for 640*480 image
    --TODO: make it resolution-specific
    if ((postStats.centroid[1] <= 10) or (postStats.centroid[1] >= 310)) then
      if(GDEBUG==1) then print("Centroid too close to image border at ",postStats.centroid[1]); end;
      valid = false;
    end

   --frespace check
   if Config.vision.goalgreen==1 then
--      print("freespace check")
      -- Surrounding free space check
--      print(Vision.colorCount[color]);
      if Vision.colorCount[color]<10000 then -- only check small goalpost
--        print("goal large enough to check");
        local PatternSiz = 20;
        local PatternPer = 0.7;
        local PatternPer_GR = 0.3;
--        print(unpack(postStats.boundingBox));
        Pattern_Below = {postStats.boundingBox[1]-10,postStats.boundingBox[2]+10,
                         postStats.boundingBox[4],postStats.boundingBox[4]+PatternSiz-1};
        -- boundary check
        if (Pattern_Below[1]<1) then Pattern_Below[1]=1 end
        if (Pattern_Below[2]>Vision.labelA.m) then Pattern_Below[2]=Vision.labelA.m end
        if (Pattern_Below[3]<1) then Pattern_Below[3]=1 end    
        if (Pattern_Below[4]>Vision.labelA.n) then Pattern_Below[4] = Vision.labelA.n; end 
        local PatternArea = (Pattern_Below[2]-Pattern_Below[1]+1)*(Pattern_Below[4]-Pattern_Below[3]+1);
        -- Check Freespace Below
        local FieldStats_Below = ImageProc.color_stats(Vision.labelA.data,
                               Vision.labelA.m,Vision.labelA.n,
                               colorField,Pattern_Below);
        local FieldStats_Below_WH= ImageProc.color_stats(Vision.labelA.data,
                               Vision.labelA.m,Vision.labelA.n,
                               colorWhite,Pattern_Below);
        local FreeArea_Below = FieldStats_Below.area+FieldStats_Below_WH.area;
        local FreePer_Below = FreeArea_Below / PatternArea;
        local FreePer_Below_GR = FieldStats_Below.area/PatternArea;
--       print(string.format("Green Area %d, Green %% %.2f",FreeArea_Below,FreePer_Below));
--        print("no green enough"..FreePer_Below_GR);
        if (FreePer_Below<PatternPer) then 
--            if (GDEBUG==1) then 
 print(string.format("Green check fail %d %d %.2f %d",FieldStats_Below.area,FieldStats_Below_WH.area,FreePer_Below,PatternArea));
--            end
            valid=false;
        elseif (FreePer_Below_GR<PatternPer_GR) then
--           if (GDEBUG==1) then 
print("no enough green "..FreePer_Below_GR); 
--           end;
            valid=false;    
        end
--     if valid==true then print("green check pass"); end
     end -- free space check        
   end

    -- Add this goal post to our queue
    if (valid) then
      ivalidB[#ivalidB+1] = i;
      npost = npost + 1;
      postA[npost] = postStats;
    end
  end

  -- If we see three posts, then there is a problem.  If we see 0, then exit
  if ((npost < 1) or (npost > 2)) then
    if (GDEBUG==1) then print('Number of posts not right: '..npost) end 
    return goal;
  end


  -- Given the valid goal posts, let's look for their world position
  goal.propsB = {};
  goal.propsA = {};
  goal.v = {};
  goal.p = {};
  for i = 1,npost do
    goal.propsB[i] = postB[ivalidB[i]];
    goal.propsA[i] = postA[i];
    -- From Mike Hopkins, VT:
    -- To fix the extra fat goal post problem, I use this code to calculate the scale. It uses the median scale if you can see the whole post and maximum if you only see part of the post. Should work for both head inverted or not inverted.

    postA[i].axisMinor = 1.0 * postA[i].axisMinor;

--[[
    local scales = {postA[i].axisMinor/postDiameter,
                    postA[i].axisMajor/postHeight,
                    math.sqrt(postA[i].area/(postDiameter*postHeight))};
    table.sort(scales);
    scale = scales[1];
    if (postA[i].boundingBox[3]<10) or (postA[i].boundingBox[4]>230) then
    --  print('Using the max')  
      scale = scales[3]; --use max
    else
       print('Using the median')
      --  scale = scales[2]; --use median 
    end
--]]


-- Old scale code before Mike
      scale = math.max(postA[i].axisMinor/postDiameter,
                        postA[i].axisMajor/postHeight,
                        math.sqrt(postA[i].area/(postDiameter*postHeight)));


    -- We know how far away the object is (scale) and its centroid, so find world coordinates
    goal.v[i] = HeadTransform.coordinatesA(postA[i].centroid, scale);

    goal.p[i]={};
    goal.p[i][1],goal.p[i][2],goal.p[i][3],goal.p[i][4], goal.p[i][5]=
	      goal.propsA[i].centroid[1],goal.propsA[i].centroid[2],
	      goal.propsA[i].axisMajor,goal.propsA[i].orientation,
	      goal.propsA[i].axisMinor;

    if (GDEBUG==1) then
      print(string.format("post[%d] = %.2f %.2f %.2f", i, goal.v[i][1], goal.v[i][2], goal.v[i][3]));
    end
  end -- for each valid post


  -- TODO: this is really arbitrary.  Should be fixed in the validation step
  --SJ: we are seeing tiny wrong posts
  -- eliminate small posts without cross bars
  --if (postA[1].area < 200) then
  if (postA[1].area < 100) then
    if (GDEBUG==1) then print('Mini post detected and we throw out our observations '..postA[1].area); end
    return goal;
  end


  --
  -- We know where each post is.  Now let's sort them according to left, right, unknown, and both

  -- With two valid goal posts, we see the whole goal
  if (npost == 2) then
    goal.type = 3;
    -- check for valid separation between posts:
    local dgoal = postA[2].centroid[1]-postA[1].centroid[1];
    local dpost = math.max(postA[1].axisMajor, postA[2].axisMajor);
    if (GDEBUG==1) then print('Found two posts!'); end
    -- If the width of the goal post is too big or too small, then get outta here
    if ((dgoal > 3.75*dpost) or (dgoal < 0.25*dpost)) then
      if (GDEBUG==1) then print('The two posts are too far/close... '..dgoal/dpost); 
end
      return goal;
    end
  -- See only one valid goal post
  else

    -- TODO: this is really arbitrary.  Should be fixed in the validation step
    --SJ: we are seeing tiny wrong posts
    -- eliminate small posts without cross bars
      if (postA[1].area < 100) then
--    if (postA[1].area < 200) then
      if (GDEBUG==1) then print('Mini post detected and we throw out our observations'); end
      return goal;
    end


    goal.v[2] = vector.new({0,0,0,0});
    goal.p[2] = vector.new({0,0,0,0});


    local postWidth = postA[1].axisMinor;
    --postWisth = postWidth*1.3;

    -- Get Rotated Box w.r.t Boundingbox
    local BBox = bboxRot(postA[1].boundingBox,
                         postA[1].centroid,math.pi/2,
                         postA[1].axisMajor);
    -- ColorStats Rotated Box
    local RotCrossbarStats=ImageProc.color_stats(Vision.labelA.data,
        Vision.labelA.m,Vision.labelA.n,color,BBox);
--[[
    if (RotCrossbarStats.area>500) then
      -- Compare to top center x
      local benchPoint=postA[1].centroid[1]+
            postA[1].axisMajor/2*math.cos(postA[1].orientation);
      if (RotCrossbarStats.centroid[1]>benchPoint) then 
       goal.type = 1;--Left post
        if GDEBUG==1 then print("Left post"); end
      else
        goal.type = 2;--Right post
        if GDEBUG==1 then print("Right post"); end
      end

    -- Not enough information to know the left or right type
    else
--]]
      -- unknown post
      goal.type = 0;
      if GDEBUG==1 then print("Unknown post"); end

--    end
--
  end

--  print(goal.v[1][3]);
  goal.detect = 1;
--  print(goal.v[1][3]);
  return goal;
end

