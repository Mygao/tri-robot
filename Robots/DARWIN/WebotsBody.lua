local WebotsBody = {}
local ww, cw, mw, kw, sw, fw, rw, vw, kb
local ffi = require'ffi'
require'wcm'
local util = require'util'
local T = require'Transform'

local get_time = webots.wb_robot_get_time

local nJoint = Config.nJoint
local jointNames = Config.jointNames
local servo = Config.servo

-- Added to Config rather than hard-coded
local ENABLE_CAMERA, NEXT_CAMERA = Config.sensors.head_camera, 0
local ENABLE_CHEST_LIDAR, NEXT_CHEST_LIDAR  = Config.sensors.chest_lidar, 0
local ENABLE_HEAD_LIDAR, NEXT_HEAD_LIDAR = Config.sensors.head_lidar, 0
local ENABLE_FSR = Config.sensors.fsr
local ENABLE_FT = Config.sensors.ft
local ENABLE_KINECT, NEXT_KINECT = Config.sensors.kinect, 0
local ENABLE_POSE = true
local ENABLE_IMU = true

local OLD_API = webots.wb_device_get_type(webots.wb_robot_get_device(jointNames[1]))==89
OLD_API=true --HACK FOR DARWIN OP PROTO
local set_pos, get_pos = webots.wb_motor_set_position, webots.wb_motor_get_position
if OLD_API then
	set_pos = webots.wb_servo_set_position
	get_pos = webots.wb_servo_get_position
end
local PID_P = 32 * vector.ones(nJoint)

-- Acquire the timesteps
local timeStep = webots.wb_robot_get_basic_time_step()
local camera_timeStep = math.max(Config.camera_timestep or 33, timeStep)
local lidar_timeStep = math.max(Config.lidar_timestep or 25, timeStep)
local kinect_timeStep = math.max(Config.kinect_timestep or 30, timeStep)

-- Setup the webots tags
local tags = {}
local t_last_error = -math.huge

tags.receiver = webots.wb_robot_get_device("receiver")
if tags.receiver>0 then
	webots.wb_receiver_enable(tags.receiver, timeStep)
	webots.wb_receiver_set_channel(tags.receiver, 13)
end


-- Ability to turn on/off items
local t_last_keypress = get_time()
webots.wb_robot_keyboard_enable(100)

local key_action = {
		h = function(override)
			if override~=nil then en=override else en=ENABLE_HEAD_LIDAR==false end
      if en==false and tags.head_lidar then
        print(util.color('HEAD_LIDAR disabled!','yellow'))
        webots.wb_camera_disable(tags.head_lidar)
        ENABLE_HEAD_LIDAR = false
      elseif tags.head_lidar then
        print(util.color('HEAD_LIDAR enabled!','green'))
        webots.wb_camera_enable(tags.head_lidar,lidar_timeStep)
				NEXT_HEAD_LIDAR = get_time() + lidar_timeStep / 1000
        ENABLE_HEAD_LIDAR = true
      end
    end,
    l = function(override)
			if override~=nil then en=override else en=ENABLE_CHEST_LIDAR==false end
      if en==false and tags.chest_lidar then
        print(util.color('CHEST_LIDAR disabled!','yellow'))
        webots.wb_camera_disable(tags.chest_lidar)
        ENABLE_CHEST_LIDAR = false
      elseif tags.chest_lidar then
        print(util.color('CHEST_LIDAR enabled!','green'))
        webots.wb_camera_enable(tags.chest_lidar,lidar_timeStep)
				NEXT_CHEST_LIDAR = get_time() + lidar_timeStep / 1000
        ENABLE_CHEST_LIDAR = true
      end
    end,
    k = function(override)
      if override~=nil then en=override else en=ENABLE_KINECT==false end
      if en==false and tags.kinect then
        print(util.color('KINECT disabled!','yellow'))
        webots.wb_camera_disable(tags.kinect)
        ENABLE_KINECT = false
      elseif tags.kinect then
        print(util.color('KINECT enabled!','green'))
        webots.wb_camera_enable(tags.kinect, kinect_timeStep)
				NEXT_KINECT = get_time() + kinect_timeStep / 1000
        ENABLE_KINECT = true
      end
    end,
    c = function(override)
      if override~=nil then en=override else en=ENABLE_CAMERA==false end
      if en==false then
        print(util.color('CAMERA disabled!','yellow'))
        webots.wb_camera_disable(tags.head_camera)
        ENABLE_CAMERA = false
      else
        print(util.color('CAMERA enabled!','green'))
        webots.wb_camera_enable(tags.head_camera,camera_timeStep)
				NEXT_CAMERA = get_time() + camera_timeStep / 1000
        ENABLE_CAMERA = true
      end
    end,
		p = function(override)
			if override~=nil then en=override else en=ENABLE_POSE==false end
      if en==false then
        print(util.color('POSE disabled!','yellow'))
        webots.wb_gps_disable(tags.gps)
	  		webots.wb_compass_disable(tags.compass)
				webots.wb_inertial_unit_disable(tags.inertialunit)
        ENABLE_POSE = false
      else
        print(util.color('POSE enabled!','green'))
        webots.wb_gps_enable(tags.gps, timeStep)
	  		webots.wb_compass_enable(tags.compass, timeStep)
				webots.wb_inertial_unit_enable(tags.inertialunit, timeStep)
        ENABLE_POSE = true
      end
    end,
		i = function(override)
			if override~=nil then en=override else en=ENABLE_IMU==false end
      if en==false then
        print(util.color('IMU disabled!','yellow'))
        webots.wb_accelerometer_disable(tags.accelerometer)
  			webots.wb_gyro_disable(tags.gyro)
        ENABLE_IMU = false
      else
        print(util.color('IMU enabled!','green'))
        webots.wb_accelerometer_enable(tags.accelerometer, timeStep)
  			webots.wb_gyro_enable(tags.gyro, timeStep)
        ENABLE_IMU = true
      end
    end,
		f = function(override)
			if override~=nil then en=override else en=ENABLE_FSR==false end
      if en==false then
        print(util.color('FSR disabled!','yellow'))
        webots.wb_touch_sensor_disable(tags.l_fsr)
  			webots.wb_touch_sensor_disable(tags.r_fsr)
        ENABLE_FSR = false
      else
        print(util.color('FSR enabled!','green'))
        webots.wb_touch_sensor_enable(tags.l_fsr, timeStep)
  			webots.wb_touch_sensor_enable(tags.r_fsr, timeStep)
        ENABLE_FSR = true
      end
    end,
		t = function(override)
			if override~=nil then en=override else en=ENABLE_FT==false end
      if en==false then
        print(util.color('FT disabled!','yellow'))
        webots.wb_touch_sensor_disable(tags.l_ft)
  			webots.wb_touch_sensor_disable(tags.r_ft)
        webots.wb_motor_disable_force_feedback(tags.jointsByName.FootR)
        webots.wb_motor_disable_force_feedback(tags.jointsByName.FootL)
        webots.wb_motor_disable_force_feedback(tags.jointsByName.AnkleR)
        webots.wb_motor_disable_force_feedback(tags.jointsByName.AnkleL)
        ENABLE_FT = false
      else
        print(util.color('FT enabled!','green'))
        webots.wb_touch_sensor_enable(tags.l_ft, timeStep)
  			webots.wb_touch_sensor_enable(tags.r_ft, timeStep)
        webots.wb_motor_enable_force_feedback(tags.jointsByName.FootR, timeStep)
        webots.wb_motor_enable_force_feedback(tags.jointsByName.FootL, timeStep)
        webots.wb_motor_enable_force_feedback(tags.jointsByName.AnkleR, timeStep)
        webots.wb_motor_enable_force_feedback(tags.jointsByName.AnkleL, timeStep)
        ENABLE_FT = true
      end
    end,
  }






function WebotsBody.entry(Body)
  -- Request @ t=0 to always be earlier than position reads
	-- Grab the tags from the joint names
	tags.joints, tags.jointsByName = {}, {}
	for i,v in ipairs(jointNames) do
    local tag=0
    if v~="null" then
      tag = webots.wb_robot_get_device(v)
    end

		tags.joints[i] = tag
    tags.jointsByName[v] = tag
		if tag > 0 then
			if OLD_API then
				webots.wb_servo_enable_position(tag, timeStep)
        webots.wb_servo_set_velocity(tag, 4)
			else
				webots.wb_motor_enable_position(tag, timeStep)
				-- Add Torque feedback
				if v~='ChestLidarPan' then
					webots.wb_motor_enable_force_feedback(tag, timeStep)
				end
			end
		end
	end

	-- Add Sensor Tags
	tags.accelerometer = webots.wb_robot_get_device("Accelerometer")
	tags.gyro = webots.wb_robot_get_device("Gyro")
	tags.gps = webots.wb_robot_get_device("GPS")
	tags.compass = webots.wb_robot_get_device("Compass")
	tags.inertialunit = webots.wb_robot_get_device("InertialUnit")

  if Config.sensors.head_camera then tags.head_camera = webots.wb_robot_get_device("HeadCamera") end
  if Config.sensors.chest_lidar then tags.chest_lidar = webots.wb_robot_get_device("ChestLidar") end
  if Config.sensors.head_lidar then tags.head_lidar = webots.wb_robot_get_device("HeadLidar") end
  if Config.sensors.kinect then tags.kinect = webots.wb_robot_get_device("kinect") end
  --[[
  if Config.sensors.fsr then
    tags.l_fsr = webots.wb_robot_get_device("L_FSR")
    tags.r_fsr = webots.wb_robot_get_device("R_FSR")
  end
  --]]
  if Config.sensors.ft then
		tags.l_ft = webots.wb_robot_get_device("LAnkle_force")
    tags.r_ft = webots.wb_robot_get_device("RAnkle_force")
  end

	-- Enable or disable the sensors
	key_action.i(ENABLE_IMU)
	key_action.p(ENABLE_POSE)
	if ENABLE_CAMERA then key_action.c(ENABLE_CAMERA) end
  if ENABLE_CHEST_LIDAR then key_action.l(ENABLE_CHEST_LIDAR) end
	if ENABLE_HEAD_LIDAR then key_action.h(ENABLE_HEAD_LIDAR) end
	if ENABLE_KINECT then key_action.k(ENABLE_KINECT) end
	if ENABLE_FT then key_action.t(ENABLE_FT) end

	-- Ensure torqued on
	Body.set_torque_enable(1)
	-- Take a step to get some values
	webots.wb_robot_step(timeStep)

  -- PID setting
  Body.set_position_p(PID_P)

	local rad, val
	local positions = vector.zeros(nJoint)

  for idx, jtag in ipairs(tags.joints) do
    if jtag>0 then
      -- Update the PID if necessary
      if not OLD_API and webots.wb_motor_set_control_pid then
--          webots.wb_motor_set_control_pid(jtag, PID_P[idx], 0, 0)
      end
			val = get_pos(jtag)
      rad = servo.direction[idx] * val - servo.rad_offset[idx]
			rad = rad==rad and rad or 0
			positions[idx] = rad
    end
  end
	dcm.set_sensor_position(positions)
	dcm.set_actuator_command_position(positions)
	Body.tags = tags

	cw = Config.sensors.head_camera and require(Config.sensors.head_camera)
	vw = Config.sensors.vision and require(Config.sensors.vision)
  kw = Config.sensors.kinect and require(Config.sensors.kinect)
	--
	fw = Config.sensors.feedback and require(Config.sensors.feedback)
  ww = Config.sensors.world and require(Config.sensors.world)
	kb = Config.testfile and require(Config.testfile)
	--
	mw = Config.sensors.mesh and require(Config.sensors.mesh)
	sw = Config.sensors.slam and require(Config.sensors.slam)


	-- Marcell
	--rw = Config.wizards.remote and require(Config.wizards.remote)

	WebotsBody.USING_KB = type(kb)=='table' and type(kb.update)=='function'

	if ww then ww.entry() end
  if fw then fw.entry() end
  if rw then rw.entry() end
	if mw then mw.entry() end
	if sw then sw.entry() end
	if vw and vw.entry then vw.entry() end
  if kw and kw.entry then kw.entry() end
end


--local depth_array = carray.float(depth.data, n_pixels)
local depth_fl = ffi.new('float[?]', 1)
local n_depth_fl = ffi.sizeof(depth_fl)
local fl_sz = ffi.sizeof('float')
function WebotsBody.update_chest_kinect(rgb, depth)
	--util.ptable(depth)
	local n_pixels = depth.width * depth.height
	if n_pixels~=n_depth_fl then depth_fl = ffi.new('float[?]', n_pixels) end
	local byte_sz = n_pixels * fl_sz
	ffi.copy(depth_fl, depth.data, byte_sz)
	-- Convert to mm
	for i=0,n_pixels-1 do depth_fl[i] = 1000 * depth_fl[i] end
	depth.data = ffi.string(depth_fl, byte_sz)
	depth.bpp = fl_sz
	if kw then kw.update(rgb, depth) end
end

function WebotsBody.update_head_camera(img, sz, cnt, t)
	if cw then
		local meta, raw = cw.update(img, sz, cnt, t)
		-- Then run vision
		if vw then vw.update(meta, raw) end
	end

end
function WebotsBody.update_head_lidar(metadata, ranges)
	if sw then sw.update(metadata, ranges) end
	if mw then mw.update(metadata, ranges) end
end
function WebotsBody.update_chest_lidar(metadata, ranges)
	if mw then mw.update(metadata, ranges) end
end


function WebotsBody.update(Body)



		local get_time = webots.wb_robot_get_time

    local t = get_time()
		-- Set actuator commands from shared memory
		local cmds = Body.get_command_position()
		local poss = Body.get_position()
    local cmdt = Body.get_command_torque()
		for idx, jtag in ipairs(tags.joints) do
			local cmd, pos = cmds[idx], poss[idx]
			-- TODO: What is velocity?
			local vel = 0 or Body.get_command_velocity()[idx]
			local en = Body.get_torque_enable()[idx]
			if en>0 and jtag>0 then
				-- Only update the joint if the motor is torqued on
				if jointNames[idx]:lower():find('grip') or jointNames[idx]:lower():find('trigger') then
					webots.wb_motor_set_available_torque(jtag, 8)
				end
        -- Update the PID
			--[[
        if not OLD_API then
          local new_P, old_P = Body.get_position_p()[idx], PID_P[idx]
          if new_P ~= old_P then
            PID_P[idx] = new_P
            webots.wb_motor_set_control_pid(jtag, new_P, 0, 0)
          end
        end
			--]]
        local rad = servo.direction[idx] * (cmd + servo.rad_offset[idx])

        --SJ: if torque enable is set to 2, it's torque control mode
        if en==1 then
          set_pos(jtag, rad)
        elseif en==2 then
--          webots.wb_motor_set_torque(jtag,servo.direction[idx]*cmdt[idx])

--for whatever reason the torque direction is inverted
          webots.wb_motor_set_torque(jtag,-servo.direction[idx]*cmdt[idx])
        end

 	 	elseif en==0 and jtag>0 then
				-- Disabling torque
				if jointNames[idx]:lower():find('grip') or jointNames[idx]:lower():find('trigger') then
					webots.wb_motor_set_available_torque(jtag, 0.01)
				end
      end
		end --for

		-- Step the simulation, and shutdown if the update fails
		if webots.wb_robot_step(Body.timeStep) < 0 then os.exit() end
		t = get_time()

    if ENABLE_IMU then
      -- Accelerometer data (verified)
      local accel = webots.wb_accelerometer_get_values(tags.accelerometer)
      dcm.sensorPtr.accelerometer[0] = (accel[1]-512)/128
      dcm.sensorPtr.accelerometer[1] = (accel[2]-512)/128
      dcm.sensorPtr.accelerometer[2] = (accel[3]-512)/128
      -- Gyro data (verified)
      local gyro = webots.wb_gyro_get_values(tags.gyro)
      dcm.sensorPtr.gyro[0] = -(gyro[1]-512)/512*39.24
      dcm.sensorPtr.gyro[1] = -(gyro[2]-512)/512*39.24
      dcm.sensorPtr.gyro[2] = (gyro[3]-512)/512*39.24
    end

    -- FSR
    if ENABLE_FSR then
      dcm.sensorPtr.lfoot[0] = webots.wb_touch_sensor_get_value(tags.l_fsr)
      dcm.sensorPtr.rfoot[0] = webots.wb_touch_sensor_get_value(tags.r_fsr)
    end

		-- F/T sensor
    if ENABLE_FT then
          local l_ft = Body.get_lfoot()
        local r_ft = Body.get_rfoot()
        if Config.birdwalk then
        --LR FT sensors are flipped
        --And their values are inverted
        l_ft[2], l_ft[3], l_ft[1] = unpack(webots.wb_touch_sensor_get_values(tags.r_ft))
        l_ft[1],l_ft[2]=-l_ft[1],-l_ft[2]
        l_ft[5] = -webots.wb_motor_get_force_feedback(tags.jointsByName.AnkleR) --pitch
        l_ft[4] = -webots.wb_motor_get_force_feedback(tags.jointsByName.FootR) --roll
        l_ft[6] = 0 --No z torque sensing (unneceesary)

        r_ft[2], r_ft[3], r_ft[1] = unpack(webots.wb_touch_sensor_get_values(tags.l_ft))
        r_ft[1],r_ft[2]=-r_ft[1],-r_ft[2]
        r_ft[5] = -webots.wb_motor_get_force_feedback(tags.jointsByName.AnkleL) --pitch
        r_ft[4] = -webots.wb_motor_get_force_feedback(tags.jointsByName.FootL) --roll
        r_ft[6] = 0
      else
        l_ft[2], l_ft[3], l_ft[1] = unpack(webots.wb_touch_sensor_get_values(tags.l_ft))
        l_ft[5] = webots.wb_motor_get_force_feedback(tags.jointsByName.AnkleL)
        l_ft[4] = webots.wb_motor_get_force_feedback(tags.jointsByName.FootL)
        l_ft[6] = 0 --No z torque sensing (unneceesary)
        r_ft[2], r_ft[3], r_ft[1] = unpack(webots.wb_touch_sensor_get_values(tags.r_ft))
        r_ft[5] = webots.wb_motor_get_force_feedback(tags.jointsByName.AnkleR)
        r_ft[4] = webots.wb_motor_get_force_feedback(tags.jointsByName.FootR)
        r_ft[6] = 0
      end
      dcm.set_sensor_lfoot(l_ft)
      dcm.set_sensor_rfoot(r_ft)

      --find immediate zmp error
      local zf_touchdown = 30
      local lzmp,rzmp={0,0},{0,0}
      if l_ft[3]>zf_touchdown then
        lzmp={l_ft[5]/l_ft[3],-l_ft[4]/l_ft[3]}
      end
      if r_ft[3]>zf_touchdown then
        rzmp={r_ft[5]/r_ft[3],-r_ft[4]/r_ft[3]}
      end
      dcm.set_sensor_lzmp(lzmp)
      dcm.set_sensor_rzmp(rzmp)
    end

    -- GPS and compass data
    -- Webots x is our y, Webots y is our z, Webots z is our x,
    -- Our x is Webots z, Our y is Webots x, Our z is Webots y
    if ENABLE_POSE then
      local gps     = webots.wb_gps_get_values(tags.gps)
      local compass = webots.wb_compass_get_values(tags.compass)
--      if Config.use_gps_pose and Config.debug.world then
--        print("raw gps:",unpack(gps))
--      end
			--local angle   = math.atan2( compass[3], compass[1] )
      --local pose    = vector.pose{gps[3], gps[1], angle}

			-- Fixed for robocup wbt
      local angle   = math.atan2( compass[1], -compass[3] )
      local pose    = vector.pose{-gps[1], gps[3], angle}

      wcm.set_robot_pose_gps( pose )
      local rpy = webots.wb_inertial_unit_get_roll_pitch_yaw(tags.inertialunit)

      --SJ: we need to remap rpy for webots
      dcm.sensorPtr.rpy[0], dcm.sensorPtr.rpy[1], dcm.sensorPtr.rpy[2] =
        rpy[2], rpy[1], -rpy[3]

      --[[
      print('rpy',unpack(rpy) )
      print('gps',unpack(gps) )
      print('compass',unpack(compass) )
      print('pose', pose )
      print()
      --]]
    end

		-- Update the sensor readings of the joint positions
		local rad, val
		local positions = dcm.get_sensor_position()

    for idx, jtag in ipairs(tags.joints) do
      if jtag>0 then
  				val = get_pos(jtag)
        rad = servo.direction[idx] * val - servo.rad_offset[idx]
				rad = rad==rad and rad or 0
				positions[idx] = rad
				if not OLD_API then
					local tq = webots.wb_motor_get_force_feedback(jtag)

					dcm.sensorPtr.current[idx-1] = tq==tq and tq*servo.direction[idx] or 0
				end
      end
    end
		dcm.set_sensor_position(positions)
		dcm.set_tsensor_position(t*vector.ones(#positions))

    -- Grab a camera frame
    if ENABLE_CAMERA and t >= NEXT_CAMERA then
      local w = webots.wb_camera_get_width(tags.head_camera)
      local h = webots.wb_camera_get_height(tags.head_camera)
      local img = ImageProc.rgb_to_yuyv(webots.to_rgb(tags.head_camera), w, h)
			WebotsBody.update_head_camera(img, 2*w*h, 0, t)
			NEXT_CAMERA = t + camera_timeStep / 1000
    end
    -- Grab a kinect frame
    if ENABLE_KINECT and t >= NEXT_KINECT then
      local w = webots.wb_camera_get_width(tags.kinect)
      local h = webots.wb_camera_get_height(tags.kinect)
			local rgb = {
				data = webots.to_rgb(tags.kinect),
				width = w,
				height = h,
				t = t,
			}
			local depth = {
				data = webots.wb_camera_get_range_image(tags.kinect),
				width = w,
				height = h,
				t = t,
			}
			WebotsBody.update_chest_kinect(rgb, depth)
			NEXT_KINECT = t + kinect_timeStep / 1000
    end

    -- Grab a lidar scan
    if ENABLE_CHEST_LIDAR and t >= NEXT_CHEST_LIDAR then
      local n = webots.wb_camera_get_width(tags.chest_lidar)
			local fov = webots.wb_camera_get_fov(tags.chest_lidar)
			local res = fov / n
      local ranges = webots.wb_camera_get_range_image(tags.chest_lidar)

			local rpy = Body.get_rpy()
			local uComp = mcm.get_stance_uTorsoComp()
			uComp[3] = 0

			local torso0 = util.pose_global(uComp, mcm.get_status_bodyOffset())
			local pose = wcm.get_robot_pose()
			local torsoG = util.pose_global(torso0, pose)
			local bh = mcm.get_stance_bodyHeight()

			local metadata = {
        id='lidar0', n=n,res=res,t=t,angle=Body.get_lidar_position(),
				tfL6 = {torso0.x, torso0.y, bh, rpy[1], rpy[2], torso0.a},
				tfG6 = {torsoG.x, torsoG.y, bh, rpy[1], rpy[2], torsoG.a},
				qWaist = Body.get_waist_position()
      }
			metadata.tfL16 = T.flatten(T.transform6D(metadata.tfL6))
			metadata.tfG16 = T.flatten(T.transform6D(metadata.tfG6))
			WebotsBody.update_chest_lidar(metadata,ranges)
      --local lidar_array = require'carray'.float(ranges, w)
			NEXT_CHEST_LIDAR = t + lidar_timeStep / 1000
    end
    -- Grab a lidar scan
    if ENABLE_HEAD_LIDAR and t >= NEXT_HEAD_LIDAR then
      local n = webots.wb_camera_get_width(tags.head_lidar)
      local fov = webots.wb_camera_get_fov(tags.head_lidar)
      local res = fov / n
      local ranges = webots.wb_camera_get_range_image(tags.head_lidar)
			local rpy = Body.get_rpy()
			local uComp = mcm.get_stance_uTorsoComp()
			uComp[3] = 0

			local torso0 = util.pose_global(uComp, mcm.get_status_bodyOffset())
			local pose = wcm.get_robot_pose()
			local torsoG = util.pose_global(torso0, pose)
			local bh = mcm.get_stance_bodyHeight()

			local metadata = {
        id='lidar1', n=n,res=res,t=t,angle=Body.get_head_position(),
				tfL6 = {torso0.x, torso0.y, bh, rpy[1], rpy[2], torso0.a},
				tfG6 = {torsoG.x, torsoG.y, bh, rpy[1], rpy[2], torsoG.a},
				qWaist = Body.get_waist_position()
      }
			metadata.tfL16 = T.flatten(T.transform6D(metadata.tfL6))
			metadata.tfG16 = T.flatten(T.transform6D(metadata.tfG6))
      WebotsBody.update_head_lidar(metadata, ranges)
      NEXT_HEAD_LIDAR = t + lidar_timeStep / 1000
    end

		-- Receive webot messaging
		while webots.wb_receiver_get_queue_length(tags.receiver) > 0 do
	    -- get first message on the queue
	    ndata = webots.wb_receiver_get_data_size(tags.receiver)
	    msg = webots.wb_receiver_get_data(tags.receiver)
	    if #msg==14 then
	    	local ball_gpsx=(tonumber(string.sub(msg,2,6))-5)*2
	    	local ball_gpsy=(tonumber(string.sub(msg,8,12))-5)*2
	    	wcm.set_robot_gpsball({ball_gpsx,ball_gpsy});

        local timestarted = wcm.get_robot_timestarted()
        if Config.stop_after_score and timestarted~=0 and ball_gpsx>4.5 then
          print("=========================================")
          print("=========================================")
          local score_time = get_time()-timestarted
          local score_min = math.floor(score_time/60)
          local score_sec = score_time%60
          print(string.format(
            "SCORED AT %d min %d sec",score_min, score_sec))
          print("=========================================")
          print("=========================================")
          wcm.set_robot_timestarted(0)
          gcm.set_game_state(4) --Set to finished
          head_ch:send'teleop'
        end
--	    	print("ball:",ball_gpsx,ball_gpsy)
	  	elseif #msg==16 then
    		local obsx=(tonumber(string.sub(msg,2,6))-5)*2
    		local obsy=(tonumber(string.sub(msg,8,12))-5)*2
    		local obsid = tonumber(string.sub(msg,14,14))
--    		print("obs:",obsid,obsx,obsy)
				if obsid==1 then wcm.set_robot_gpsobs1({obsx,obsy})
				else wcm.set_robot_gpsobs2({obsx,obsy}) end
    	end
	    webots.wb_receiver_next_packet(tags.receiver)
	  end

		-- Grab keyboard input, for modifying items
    local key_code = webots.wb_robot_keyboard_get_key()
		if ww then ww.update() end
  	if fw then fw.update() end
  	if rw then rw.update() end
		if WebotsBody.USING_KB then kb.update(key_code) end
end

function WebotsBody.exit() if ww then ww.exit() end end

return WebotsBody
