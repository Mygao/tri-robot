-- DCM is a thread or standalone
local CTX, metadata = ...
-- Still need our library paths set
dofile'include.lua'
--assert(ffi, 'IMU | Please use LuaJIT :). Lua support in the near future')
-- Going to be threading this
local si = require'simple_ipc'
-- Import the context
local parent_ch, IS_THREAD
if CTX and not arg then
	IS_THREAD = true
	si.import_context(CTX)
	-- Communicate with the master thread
	parent_ch = si.new_pair(metadata.ch_name)
end
imu_ch = si.new_subscriber'imu!'
-- Reset the metadata, since only one imu on file
metadata = Config.imu
-- Fallback on undefined metadata
assert(metadata, 'IMU | No metadata found!')
local running = true
local function shutdown()
	running = false
end
if not IS_THREAD then
  signal = require'signal'
  signal.signal("SIGINT", shutdown)
  signal.signal("SIGTERM", shutdown)
end

local OVERRIDE_YAW = true
local CALIBRATE_GYRO_BIAS = true

-- Modules
require'dcm'
local lM = require'libMicrostrain'
local vector = require'vector'

-- Cache the typical commands quickly
local get_time = unix.time
local acc_ptr  = dcm.sensorPtr.accelerometer
local gyro_ptr = dcm.sensorPtr.gyro
local mag_ptr  = dcm.sensorPtr.magnetometer
local rpy_ptr  = dcm.sensorPtr.rpy
local acc, gyro, mag, rpy = vector.zeros(3), vector.zeros(3), vector.zeros(3), vector.zeros(3)
local read_count, last_read_count = 0,0 --to get hz
local sformat = string.format

-- Local variables
local yaw = 0 --this is generated by integrating yaw gyro
local gyr0 = vector.zeros(3)
-- -1 degree every 7 seconds
local gyro_yaw_bias = (-1 / 7) * DEG_TO_RAD
local uptime, kb, fps = 0, 0, 0
local t0, t_debug, t, t_read, t_last_read
local microstrain

-- Collect garbage before starting
collectgarbage()

local function set_gyro_bias(gyr0, seconds)
  gyro_yaw_bias = gyr0 / seconds
end

local function do_read()
	-- Get the accelerometer, gyro, magnetometer, and euler angles
	local a, g, m, e, dg = microstrain:read_ahrs()
  t_read = get_time()
	if not a then return end

	-- Quickly set in shared memory
	acc_ptr[0], acc_ptr[1], acc_ptr[2] = a[1], a[2], -a[0]
	gyro_ptr[0], gyro_ptr[1], gyro_ptr[2] =
    g[1] - gyro_yaw_bias[1], g[2] - gyro_yaw_bias[2], -g[0] - gyro_yaw_bias[3]
	mag_ptr[0], mag_ptr[1], mag_ptr[2] = m[1], m[2], -m[0]
	rpy_ptr[0], rpy_ptr[1], rpy_ptr[2] = e[1], e[2], -e[0]
  -- delta yaw in that episode, less the initial offset
  local del_yaw = -dg[0] - gyr0[3]
  yaw = yaw + (del_yaw - gyro_yaw_bias * (t_read - t_last_read) )
  
  -- Overwrite the RPY value
  if OVERRIDE_YAW then rpy_ptr[2] = yaw end

  -- Save the time and count
  read_count = read_count + 1
  t_last_read = t_read
  return t_read
end

-- Open the device
microstrain = lM.new_microstrain('/dev/ttyACM0', OPERATING_SYSTEM~='darwin' and 921600)
-- Turn it on
microstrain:ahrs_on()
microstrain:ahrs_and_nav_on()
t0 = get_time()
t_debug, t_last, t = t0, t0, t0
t_last_read = t0

if CALIBRATE_GYRO_BIAS then
  local t_diff
  repeat
    t = do_read()
    t_diff = t - t0
  until t_diff > 2
  set_gyro_bias(dcm.get_sensor_gyro(), t_diff)
end

-- Run the main loop
while running do
	-----------------
	-- Read Values --
	-----------------
	t = do_read()
	--------------------
	-- Periodic Debug --
	--------------------
  if t - t_debug > 1 then
    os.execute('clear')
		kb = collectgarbage('count')
    uptime = t - t0
    fps = (read_count-last_read_count) / (t-t_debug)
    last_read_count = read_count
    local acc = dcm.get_sensor_accelerometer()
    local gyro = dcm.get_sensor_gyro()
    local mag = dcm.get_sensor_magnetometer()
    local rpy = dcm.get_sensor_rpy()
		local debug_str = {
			sformat('\nIMU | Uptime %.2f sec, Mem: %d kB', t-t0, kb),
			sformat('Acc (g): %.2f %.2f %.2f', unpack(acc)),
			sformat('Gyro (rad/s): %.2f %.2f %.2f', unpack(gyro)),
			sformat('Mag (Gauss): %.2f %.2f %.2f', unpack(mag)),
			sformat('RPY:  %.2f %.2f %.2f', unpack(RAD_TO_DEG * rpy)),
      sformat('Yaw: %.2f, Integration: %.2f', RAD_TO_DEG * rpy[3], RAD_TO_DEG * yaw),
		}
    debug_str = table.concat(debug_str, '\n')
    if parent_ch then
      parent_ch:send(debug_str)
    else
  		print(debug_str)
    end
    t_debug = t
  end
	---------------------
	-- Parent Commands --
	---------------------
  if parent_ch then
  	local parent_msgs = parent_ch:receive(true)
  	if parent_msgs then
  		for _, msg in ipairs(parent_msgs) do
  			if msg=='exit' then
  				shutdown()
  			end
  		end
  	end
  end
	collectgarbage('step')
end

print("Stopping...")
microstrain:ahrs_off()
microstrain:close()
if IS_THREAD then parent_ch:send'done' end
print('IMU | Exit')
