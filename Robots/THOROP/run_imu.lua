-- DCM is a thread or standalone
local CTX, metadata = ...
-- Still need our library paths set
dofile'include.lua'
--assert(ffi, 'IMU | Please use LuaJIT :). Lua support in the near future')
-- Going to be threading this
local si = require'simple_ipc'
-- Import the context
local parent_ch, IS_THREAD
if CTX and not arg then
	IS_THREAD = true
	si.import_context(CTX)
	-- Communicate with the master thread
	parent_ch = si.new_pair(metadata.ch_name)
end
imu_ch = si.new_subscriber'imu!'
-- Reset the metadata, since only one imu on file
metadata = Config.imu
-- Fallback on undefined metadata
assert(metadata, 'IMU | No metadata found!')
local running = true
local function shutdown()
	running = false
end
if not IS_THREAD then
  signal = require'signal'
  signal.signal("SIGINT", shutdown)
  signal.signal("SIGTERM", shutdown)
end

-- Modules
require'dcm'
local lM = require'libMicrostrain'
local vector = require'vector'

-- Cache the typical commands quickly
local get_time = unix.time
local acc_ptr  = dcm.sensorPtr.accelerometer
local gyro_ptr = dcm.sensorPtr.gyro
local mag_ptr  = dcm.sensorPtr.magnetometer
local rpy_ptr  = dcm.sensorPtr.rpy
local acc, gyro, mag, rpy = vector.new(3), vector.new(3), vector.new(3), vector.new(3)
local read_count, last_read_count = 0,0 --to get hz

-- Local variables
local OVERRIDE_YAW = true
local yaw = 0 --this is generated by integrating yaw gyro
local yaw0
local gyro_yaw_bias = -8*math.pi/180 / 60
local uptime, kb, fps = 0, 0, 0
local t_read, t_last_read = get_time(), get_time()

-- Open the device
print("Opening the IMU device...")
local microstrain = lM.new_microstrain('/dev/ttyACM0', OPERATING_SYSTEM~='darwin' and 921600)
print("DONE", microstrain)
-- Turn it on
-- TODO: Read and check settings...
print("Turn on IMU streaming...")
microstrain:ahrs_on()
print("DONE")

local function do_read (t)
	-- Get the accelerometer, gyro, magnetometer, and euler angles
	local a, g, m, e = microstrain:read_ahrs()
	if not a then return end
  if not yaw0 then yaw0 = -e[0] end

	-- Quickly set in shared memory
	acc_ptr[0], acc_ptr[1], acc_ptr[2] = a[1], a[2], -a[0]
	gyro_ptr[0], gyro_ptr[1], gyro_ptr[2] = g[1], g[2], -g[0]
	mag_ptr[0], mag_ptr[1], mag_ptr[2] = m[1], m[2], -m[0]
	rpy_ptr[0], rpy_ptr[1], rpy_ptr[2] = e[1], e[2], -e[0] - yaw0


  -- Save the time
  t_last_read = t_read
  t_read = t
  -- SJ: yaw gyro had consistent -8deg/minute bias
  yaw = yaw + (gyro_ptr[2] - gyro_yaw_bias) * (t_read - t_last_read)
  
  if OVERRIDE_YAW then
    -- Overwrite the RPY value
    rpy_ptr[2] = yaw
  end

  read_count = read_count + 1
end
-- Collect garbage before starting
collectgarbage()
-- Begin infinite loop
local t0 = get_time()
local t_debug, t_last, t = t0, t0, t0
-- Run the main loop
while running do
	t_last = t
	t = get_time()
	-----------------
	-- Read Values --
	-----------------
	do_read(t)
	--------------------
	-- Periodic Debug --
	--------------------
  if t - t_debug > 1 then
    os.execute('clear')
		kb = collectgarbage('count')
    uptime = t - t0
    fps = (read_count-last_read_count) / (t-t_debug)
    last_read_count = read_count
    local acc = dcm.get_sensor_accelerometer()
    local gyro = dcm.get_sensor_gyro()
    local mag = dcm.get_sensor_magnetometer()
    local rpy = dcm.get_sensor_rpy()
		local debug_str = {
			string.format('\nIMU | Uptime %.2f sec, Mem: %d kB', t-t0, kb),
			string.format('Acc (g): %.2f %.2f %.2f', unpack(acc)),
			string.format('Gyro (rad/s): %.2f %.2f %.2f', unpack(gyro)),
			string.format('Mag (Gauss): %.2f %.2f %.2f', unpack(mag)),
			string.format('RPY:  %.2f %.2f %.2f', unpack(RAD_TO_DEG * rpy)),
      string.format('Yaw: %.2f, Integration: %.2f', RAD_TO_DEG * rpy[3], RAD_TO_DEG * yaw),
		}
    debug_str = table.concat(debug_str, '\n')
    if parent_ch then
      parent_ch:send(debug_str)
    else
  		print(debug_str)
    end
    t_debug = t
  end
	---------------------
	-- Parent Commands --
	---------------------
  if parent_ch then
  	local parent_msgs = parent_ch:receive(true)
  	if parent_msgs then
  		for _, msg in ipairs(parent_msgs) do
  			if msg=='exit' then
  				shutdown()
  			end
  		end
  	end
  end
	collectgarbage('step')
end

print("Stopping...")
microstrain:ahrs_off()
microstrain:close()
if IS_THREAD then parent_ch:send'done' end
print('IMU | Exit')
