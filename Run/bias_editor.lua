dofile('include.lua')

----------------------------------------------------------------------
-- Bias Editor
----------------------------------------------------------------------

require('acm')
require('scm')
require('Body')
require('util')
require('unix')
require('curses')
require('vector')
require('Config')

local bias_file = arg[1]
  or '../Config/Robot/Config_'..Config.platform.name..'_Bias.lua'

local bias_keys = {
  [1] = 'joint_position',
  [2] = 'joint_force',
  [3] = 'motor_position',
  [4] = 'motor_force',
  [5] = 'force_torque',
  [6] = 'tactile_array',
}

local bias_increments = {
  [1] = 0.1,
  [2] = 0.1,
  [3] = 10,
  [4] = 10,
  [5] = 10,
  [6] = 0.1,
}

local bias_values = {}
local nominal_values = {}
local initial_bias_values = {}

for i = 1,#bias_keys do
  bias_values[i] = Config.bias[bias_keys[i]..'_bias']
    or vector.zeros(#scm:get_key(bias_keys[i]))
  nominal_values[i] = Config.bias[bias_keys[i]..'_nominal']
    or vector.zeros(#scm:get_key(bias_keys[i]))
  initial_bias_values[i] = vector.copy(bias_values[i]) 
end

local key_no = 1
local bias_key = bias_keys[key_no]
local bias_value = bias_values[key_no]
local nominal_value = nominal_values[key_no]
local initial_bias_value = initial_bias_values[key_no]
local bias_increment = bias_increments[key_no]

local NCOLS = 4 
local NROWS = #bias_value
local ROW_WIDTH = 1
local COL_WIDTH = 14
local COL_OFFSET = 21
local ROW_OFFSET = 4

local COL_BIASED = 1
local COL_UNBIASED = 2
local COL_NOMINAL = 3
local COL_BIAS = 4
local ROW_CMD = NROWS + 2

local row = 1
local col = 4

-- Commands
----------------------------------------------------------------------

function cmd_set_value(arg)
  local varg = parse_double_arguments(arg)
  if varg[1] then
    set_value(varg[1], row, col)
  end
  draw_screen()
end

function cmd_increment_value(scale)
  val = get_value(row, col)
  if val then
    val = val + scale*get_increment(row, col)  
    set_value(val, row, col)
  end
  draw_screen()
end

function cmd_bias(arg)
  local indices = {}
  local id = parse_string_arguments(arg)[1]
  local group = Config[scm:get_group(bias_key)]
  if (id and group.index[id]) then
    indices = group.index[id]
  else
    for i,index in pairs(parse_int_arguments(arg)) do
      if (index > 0) and (index <= #group.id) then
         indices[#indices+1] = index
      end
    end
  end
  if (type(indices) == 'number') then indices = {indices} end
  for i,index in pairs(indices) do
    bias_value[index] = scm:get_key(bias_key, index)
      + initial_bias_value[index] - nominal_value[index]
  end
  draw_screen()
end

function cmd_unbias(arg)
  local indices = {}
  local id = parse_string_arguments(arg)[1]
  local group = Config[scm:get_group(bias_key)]
  if (id and group.index[id]) then 
    indices = group.index[id]
  else
    for i,index in pairs(parse_int_arguments(arg)) do
      if (index > 0) and (index <= #group.id) then
         indices[#indices+1] = index
      end
    end
  end
  if (type(indices) == 'number') then indices = {indices} end
  for i,index in pairs(indices) do
    bias_value[index] = 0
  end
  draw_screen()
end

function cmd_next_key()
  key_no = math.min(key_no + 1, #bias_keys)

  bias_key = bias_keys[key_no]
  bias_value = bias_values[key_no]
  nominal_value = nominal_values[key_no]
  initial_bias_value = initial_bias_values[key_no]
  bias_increment = bias_increments[key_no]
  NROWS = #bias_value
  ROW_CMD = NROWS + 2
  row = 1

  draw_screen()
end

function cmd_previous_key()
  key_no = math.max(key_no - 1, 1)

  bias_key = bias_keys[key_no]
  bias_value = bias_values[key_no]
  nominal_value = nominal_values[key_no]
  initial_bias_value = initial_bias_values[key_no]
  bias_increment = bias_increments[key_no]
  NROWS = #bias_value
  ROW_CMD = NROWS + 2
  row = 1

  draw_screen()
end

function cmd_save(arg)
  local varg = parse_string_arguments(arg)
  bias_file = varg[1] or bias_file
  local f = assert(io.open(bias_file,'w+'))
  f:write('module(..., package.seeall)\n\n')
  f:write('-- this config file was automatically ')
  f:write('generated by the bias_editor utility\n\n')
  f:write('bias = {}\n\n')
  for i = 1,#bias_keys do
    f:write('bias.'..bias_keys[i]..'_bias = {\n')
    for j = 1,#bias_values[i] do
      f:write(string.format('  [%d] = %f,\n', j, bias_values[i][j]))
    end
    f:write('}\n\n')
    f:write('bias.'..bias_keys[i]..'_nominal = {\n')
    for j = 1,#nominal_values[i] do
      f:write(string.format('  [%d] = %f,\n', j, nominal_values[i][j]))
    end
    f:write('}\n\n')
  end
  f:close()
end

function cmd_quit()
  exit()
  os.exit()
end

function cmd_help()
  curses.timeout(-1)
  curses.clear()
  curses.move(0, 0)
  curses.printw('------------------------------------------------ Navigation\n')
  curses.printw('save                  write current bias values to file\n')
  curses.printw('n                     next key\n')
  curses.printw('p                     previous key\n')
  curses.printw('q                     quit\n')
  curses.printw('h                     help\n')
  curses.printw('------------------------------------------------ Editing\n')
  curses.printw('set [value]           set value under cursor\n')
  curses.printw('bias [ids]            bias ids\n')
  curses.printw('unbias [ids]          unbias ids\n')
  curses.printw('press any key to continue...')
  curses.getch()
  curses.clear()
  draw_screen()
  curses.timeout(10)
end

local commands = {
  ['save'] = cmd_save,
  ['n'] = cmd_next_key,
  ['p'] = cmd_previous_key,
  ['h'] = cmd_help,
  ['help'] = cmd_help,
  ['q'] = cmd_quit,
  ['quit'] = cmd_quit,
  ['exit'] = cmd_quit,
  ['set'] = cmd_set_value,
  ['bias'] = cmd_bias,
  ['unbias'] = cmd_unbias,
}

-- Parsing
-----------------------------------------------------------------

function parse_int_arguments(arg)
  local varg = {}
  for int in arg:gmatch('[ ,](%-?%d+)') do
    varg[#varg + 1] = tonumber(int)
  end
  return varg
end

function parse_double_arguments(arg)
  local varg = {}
  for double in arg:gmatch('[ ,](%-?%d*%.?%d+e?-?%d*)') do
    varg[#varg + 1] = tonumber(double)
  end
  return varg
end

function parse_string_arguments(arg)
  local varg = {}
  for token in arg:gmatch('[ ,](%a[%a_%d]*)') do
    varg[#varg + 1] = token 
  end
  return varg
end

function read_command(key)
  -- clear prompt
  draw_command_row('')
  -- get command string
  curses.echo()
  curses.timeout(-1)
  local str = curses.getstr()
  curses.timeout(10)
  curses.noecho()
  -- call command
  local cmd, arg = str:match('^([%a_]+)(.*)$')
  if commands[cmd] then
    commands[cmd](arg)
  elseif cmd then
    draw_command_row('Invalid command')
  end
  -- restore cursor 
  curses.move(get_cursor(row, col))
end

-- Access
---------------------------------------------------------------------

function get_value(r, c)
  if (c == COL_BIASED) then
    return scm:get_key(bias_key, r) + initial_bias_value[r] - bias_value[r]
  elseif (c == COL_UNBIASED) then
    return scm:get_key(bias_key, r) + initial_bias_value[r]
  elseif (c == COL_NOMINAL) then
    return nominal_value[r]
  elseif (c == COL_BIAS) then
    return bias_value[r]
  end
end

function set_value(val, r, c)
  if (c == COL_NOMINAL) then
    nominal_value[r] = val
  elseif (c == COL_BIAS) then
    bias_value[r] = val
  end
end

function get_increment(r, c)
  return bias_increment
end

-- Navigation
----------------------------------------------------------------------

function get_cursor(r, c)
  local y = ROW_OFFSET + (r-1)*ROW_WIDTH
  local x = COL_OFFSET + (c-1)*COL_WIDTH
  return y, x 
end

function cursor_right()
  col = math.min(col + 1, COL_BIAS)
  curses.move(get_cursor(row, col))
end

function cursor_left()
  col = math.max(col - 1, COL_NOMINAL)
  curses.move(get_cursor(row, col))
end

function cursor_up()
  row = math.max(row - 1, 1)
  curses.move(get_cursor(row, col))
end

function cursor_down()
  row = math.min(row + 1, NROWS)
  curses.move(get_cursor(row, col))
end

-- Display
----------------------------------------------------------------------

function draw_command_row(str)
  local cursory = get_cursor(ROW_CMD, 0)
  curses.move(cursory, 0)
  curses.printw(':%80s', ' ')
  curses.move(cursory, 2)
  curses.printw(str)
  curses.refresh()
end

function draw_col(c)
  for r = 1, NROWS do
    curses.move(get_cursor(r, c))
    val = get_value(r, c)
    if val then
      curses.printw('[%10.3f]', val)
    else
      curses.printw('[----------]')
    end
  end
  curses.move(get_cursor(row, col))
  curses.refresh()
end

function draw_screen()
  curses.clear()
  curses.move(0, 0)
  curses.printw('                                Bias Editor\n')
  curses.printw('///////////////////////////////////////')
  curses.printw('//////////////////////////////////////\n')
  curses.printw('%-19s %12s  %12s  %12s  %12s\n', bias_key,
    'biased', 'unbiased', 'nominal', 'bias')
  curses.printw('---------------------------------------')
  curses.printw('--------------------------------------\n')
  local group = Config[scm:get_group(bias_key)]
  for i = 1,#group.id do
    curses.printw('%2d', i)
    curses.printw(' %16s\n', group.id[i])
  end
  curses.move(get_cursor(row, col))
  for c = 1,NCOLS do
    draw_col(c)
  end
  curses.refresh()
  curses.move(get_cursor(row, col))
end

-- Main
------------------------------------------------------------------

function entry()
  -- setup curses environment
  curses.initscr()
  curses.cbreak()
  curses.noecho()
  curses.keypad(1)
  curses.timeout(5)
  draw_screen()
  -- initialize shared memory
  unix.usleep(5e5)
  draw_screen()
end

function update()
  -- handle keystrokes
  local key = curses.getch()
  if key == string.byte('-') then
    cmd_increment_value(-0.2)
  elseif key == string.byte('=') then
    cmd_increment_value(0.2)
  elseif key == string.byte('_') then
    cmd_increment_value(-1)
  elseif key == string.byte('+') then
    cmd_increment_value(1)
  elseif key == string.byte('[') then
    cmd_increment_value(-2)
  elseif key == string.byte(']') then
    cmd_increment_value(2)
  elseif key == string.byte('{') then
    cmd_increment_value(-10)
  elseif key == string.byte('}') then
    cmd_increment_value(10)
  elseif key == curses.KEY_UP then
    cursor_up()
  elseif key == curses.KEY_DOWN then
    cursor_down()
  elseif key == curses.KEY_LEFT then
    cursor_left()
  elseif key == curses.KEY_RIGHT then
    cursor_right()
  elseif key then
    curses.ungetch(key)
    read_command()
  end
end

function exit()
  curses.endwin()
end

local stats = util.loop_stats(5)

entry()
while true do
  update()
  if stats.update() then
    draw_col(COL_BIASED)
    draw_col(COL_UNBIASED)
  end
end
exit()
