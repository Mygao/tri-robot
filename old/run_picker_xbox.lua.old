cwd = os.getenv('PWD')
require('init')
require 'Config'
require 'xbox'
require 'mcm'
require 'libpicker'
require('getch')
getch.enableblock(1);

-- TESTING
require 'Kinematics'

teamID   = Config.game.teamNumber;
playerID = Config.game.playerID;

print '=====================';
print('Team '..teamID,'Player '..playerID)
print '=====================';

net = false

function entry()
	-- Initialize FSMs
	xbox.entry()
	mcm.set_walk_override({1,0})
	mcm.set_walk_qLArm( {0,0,0} )
	mcm.set_walk_qRArm( {0,0,0} )
	mcm.set_walk_footX(mcm.get_footX());
	
	if( net ) then
		require 'Team'
		Team.entry(true) -- true means we have the primesense
	end

	-- Start variables
	t0 = unix.time();
	t_last_debug = t0;
	count = 0;

end

function update()
	local t_start = unix.time();
	
	-- Updates
	if not xbox.update() then
		return false
	end
	
	-- Update the SHM blocks
	mcm.set_walk_velocity( xbox.get_velocity() );
	mcm.set_walk_qLArm( xbox.get_qLArm(mcm.get_walk_qLArm()) )
	mcm.set_walk_qRArm( xbox.get_qRArm(mcm.get_walk_qRArm()) )
	mcm.set_walk_rpy( xbox.get_rpy() );
	local bh = xbox.get_bodyHeight(mcm.get_walk_bodyHeight())
	mcm.set_walk_bodyHeight( bh )
	local ph_footX = (Config.walk.bodyHeight-bh) 
	/ (Config.walk.bodyHeight-Config.stance.bodyHeightSit)
	local footX = ph_footX*-0.05 + (1-ph_footX)*mcm.get_footX();
	mcm.set_walk_footX(footX);

	unix.usleep(1e4); -- Add 10ms delay to simulate the Team sending

	
	-- User Key input
	local keycode = process_keyinput();
	if keycode==string.byte("q") then
		return false
	end
	
	-- Toggle Logging
	if keycode==string.byte("l") then
		skeleton.toggle_logging()
	end

	-- Send out information
	if net then
		Team.update()
	end

	-- Debugging
	if( t_start-t_last_debug>1 ) then
		local fps = count / (t_start-t_last_debug)
		t_last_debug = t_start
		count = 0;
		print( "Detected XBOX360 Controller?:",mcm.get_walk_override()[1])
		print( "Override Mode:",mcm.get_walk_override()[2])
		print( 'Velocity', mcm.get_walk_velocity() )
		print( 'Height', mcm.get_walk_bodyHeight() )
		print( 'Arms', mcm.get_walk_qLArm(),mcm.get_walk_qRArm() )
		print( string.format('%.1f FPS\n',fps) )
	end
	count = count+1;
	return true
end

function exit()
	skeleton.exit()
	mcm.set_walk_override( {0,0} );
end

function process_keyinput()
	local str=getch.get();
	if #str>0 then
		local byte=string.byte(str,1);
		return byte
	end
end

entry()
while true do
	if not update() then
		exit()
		break;
	end
end


-- DONE testing
function mirror_arm()
  libpicker.update()
	--Testing
	print( string.format('qLArm: %.3f, %.3f, %.3f', unpack(mcm.get_walk_qLArm()) ) )
	print( string.format('pLArm: %.3f, %.3f, %.3f', unpack(libpicker.pLArm) ) )
	local pRArm_ik = libpicker.pLArm;
	pRArm_ik[2] = math.abs(pRArm_ik[2]);

  --pRArm_ik = vector.new({.129,0,-0.060})
	print( string.format('pR_ik: %.3f, %.3f, %.3f', unpack(pRArm_ik) ) )
	local qRArm_ik = Kinematics.inverse_arm(pRArm_ik)
	if qRArm_ik then
		qRArm_ik[2] = -1*qRArm_ik[2];
		print( string.format('qRArm: %.3f, %.3f, %.3f', unpack(qRArm_ik) ) )
		local tRArm_ik = Kinematics.forward_rarm(qRArm_ik);
		pRArm_ik = vector.new({tRArm_ik[1][4],tRArm_ik[2][4],tRArm_ik[3][4]})
		print( string.format('pR_ik: %.3f, %.3f, %.3f', unpack(pRArm_ik) ) )
		mcm.set_walk_qRArm( qRArm_ik )
	end
	print()
end
